{"ast":null,"code":"import produce from 'immer';\nimport isPlainObject from 'lodash.isplainobject';\n/*\r\n * Copyright 2017 The boardgame.io Authors\r\n *\r\n * Use of this source code is governed by a MIT-style\r\n * license that can be found in the LICENSE file or at\r\n * https://opensource.org/licenses/MIT.\r\n */\n\nconst MAKE_MOVE = 'MAKE_MOVE';\nconst GAME_EVENT = 'GAME_EVENT';\nconst REDO = 'REDO';\nconst RESET = 'RESET';\nconst SYNC = 'SYNC';\nconst UNDO = 'UNDO';\nconst UPDATE = 'UPDATE';\nconst PATCH = 'PATCH';\nconst PLUGIN = 'PLUGIN';\nconst STRIP_TRANSIENTS = 'STRIP_TRANSIENTS';\n/*\r\n * Copyright 2017 The boardgame.io Authors\r\n *\r\n * Use of this source code is governed by a MIT-style\r\n * license that can be found in the LICENSE file or at\r\n * https://opensource.org/licenses/MIT.\r\n */\n\n/**\r\n * Generate a move to be dispatched to the game move reducer.\r\n *\r\n * @param {string} type - The move type.\r\n * @param {Array}  args - Additional arguments.\r\n * @param {string}  playerID - The ID of the player making this action.\r\n * @param {string}  credentials - (optional) The credentials for the player making this action.\r\n */\n\nconst makeMove = (type, args, playerID, credentials) => ({\n  type: MAKE_MOVE,\n  payload: {\n    type,\n    args,\n    playerID,\n    credentials\n  }\n});\n/**\r\n * Generate a game event to be dispatched to the flow reducer.\r\n *\r\n * @param {string} type - The event type.\r\n * @param {Array}  args - Additional arguments.\r\n * @param {string}  playerID - The ID of the player making this action.\r\n * @param {string}  credentials - (optional) The credentials for the player making this action.\r\n */\n\n\nconst gameEvent = (type, args, playerID, credentials) => ({\n  type: GAME_EVENT,\n  payload: {\n    type,\n    args,\n    playerID,\n    credentials\n  }\n});\n/**\r\n * Generate an automatic game event that is a side-effect of a move.\r\n * @param {string} type - The event type.\r\n * @param {Array}  args - Additional arguments.\r\n * @param {string}  playerID - The ID of the player making this action.\r\n * @param {string}  credentials - (optional) The credentials for the player making this action.\r\n */\n\n\nconst automaticGameEvent = (type, args, playerID, credentials) => ({\n  type: GAME_EVENT,\n  payload: {\n    type,\n    args,\n    playerID,\n    credentials\n  },\n  automatic: true\n});\n\nconst sync = info => ({\n  type: SYNC,\n  state: info.state,\n  log: info.log,\n  initialState: info.initialState,\n  clientOnly: true\n});\n/**\r\n * Used to update the Redux store's state with patch in response to\r\n * an action coming from another player.\r\n * @param prevStateID previous stateID\r\n * @param stateID stateID after this patch\r\n * @param {Operation[]} patch - The patch to apply.\r\n * @param {LogEntry[]} deltalog - A log delta.\r\n */\n\n\nconst patch = (prevStateID, stateID, patch, deltalog) => ({\n  type: PATCH,\n  prevStateID,\n  stateID,\n  patch,\n  deltalog,\n  clientOnly: true\n});\n/**\r\n * Used to update the Redux store's state in response to\r\n * an action coming from another player.\r\n * @param {object} state - The state to restore.\r\n * @param {Array} deltalog - A log delta.\r\n */\n\n\nconst update = (state, deltalog) => ({\n  type: UPDATE,\n  state,\n  deltalog,\n  clientOnly: true\n});\n/**\r\n * Used to reset the game state.\r\n * @param {object} state - The initial state.\r\n */\n\n\nconst reset = state => ({\n  type: RESET,\n  state,\n  clientOnly: true\n});\n/**\r\n * Used to undo the last move.\r\n * @param {string}  playerID - The ID of the player making this action.\r\n * @param {string}  credentials - (optional) The credentials for the player making this action.\r\n */\n\n\nconst undo = (playerID, credentials) => ({\n  type: UNDO,\n  payload: {\n    type: null,\n    args: null,\n    playerID,\n    credentials\n  }\n});\n/**\r\n * Used to redo the last undone move.\r\n * @param {string}  playerID - The ID of the player making this action.\r\n * @param {string}  credentials - (optional) The credentials for the player making this action.\r\n */\n\n\nconst redo = (playerID, credentials) => ({\n  type: REDO,\n  payload: {\n    type: null,\n    args: null,\n    playerID,\n    credentials\n  }\n});\n/**\r\n * Allows plugins to define their own actions and intercept them.\r\n */\n\n\nconst plugin = (type, args, playerID, credentials) => ({\n  type: PLUGIN,\n  payload: {\n    type,\n    args,\n    playerID,\n    credentials\n  }\n});\n/**\r\n * Private action used to strip transient metadata (e.g. errors) from the game\r\n * state.\r\n */\n\n\nconst stripTransients = () => ({\n  type: STRIP_TRANSIENTS\n});\n\nvar ActionCreators = /*#__PURE__*/Object.freeze({\n  makeMove: makeMove,\n  gameEvent: gameEvent,\n  automaticGameEvent: automaticGameEvent,\n  sync: sync,\n  patch: patch,\n  update: update,\n  reset: reset,\n  undo: undo,\n  redo: redo,\n  plugin: plugin,\n  stripTransients: stripTransients\n});\n/**\r\n * Moves can return this when they want to indicate\r\n * that the combination of arguments is illegal and\r\n * the move ought to be discarded.\r\n */\n\nconst INVALID_MOVE = 'INVALID_MOVE';\n/*\r\n * Copyright 2018 The boardgame.io Authors\r\n *\r\n * Use of this source code is governed by a MIT-style\r\n * license that can be found in the LICENSE file or at\r\n * https://opensource.org/licenses/MIT.\r\n */\n\n/**\r\n * Plugin that allows using Immer to make immutable changes\r\n * to G by just mutating it.\r\n */\n\nconst ImmerPlugin = {\n  name: 'plugin-immer',\n  fnWrap: move => (G, ctx, ...args) => {\n    let isInvalid = false;\n    const newG = produce(G, G => {\n      const result = move(G, ctx, ...args);\n\n      if (result === INVALID_MOVE) {\n        isInvalid = true;\n        return;\n      }\n\n      return result;\n    });\n    if (isInvalid) return INVALID_MOVE;\n    return newG;\n  }\n}; // Inlined version of Alea from https://github.com/davidbau/seedrandom.\n// Converted to Typescript October 2020.\n\nclass Alea {\n  constructor(seed) {\n    const mash = Mash(); // Apply the seeding algorithm from Baagoe.\n\n    this.c = 1;\n    this.s0 = mash(' ');\n    this.s1 = mash(' ');\n    this.s2 = mash(' ');\n    this.s0 -= mash(seed);\n\n    if (this.s0 < 0) {\n      this.s0 += 1;\n    }\n\n    this.s1 -= mash(seed);\n\n    if (this.s1 < 0) {\n      this.s1 += 1;\n    }\n\n    this.s2 -= mash(seed);\n\n    if (this.s2 < 0) {\n      this.s2 += 1;\n    }\n  }\n\n  next() {\n    const t = 2091639 * this.s0 + this.c * 2.3283064365386963e-10; // 2^-32\n\n    this.s0 = this.s1;\n    this.s1 = this.s2;\n    return this.s2 = t - (this.c = Math.trunc(t));\n  }\n\n}\n\nfunction Mash() {\n  let n = 0xefc8249d;\n\n  const mash = function (data) {\n    const str = data.toString();\n\n    for (let i = 0; i < str.length; i++) {\n      n += str.charCodeAt(i);\n      let h = 0.02519603282416938 * n;\n      n = h >>> 0;\n      h -= n;\n      h *= n;\n      n = h >>> 0;\n      h -= n;\n      n += h * 0x100000000; // 2^32\n    }\n\n    return (n >>> 0) * 2.3283064365386963e-10; // 2^-32\n  };\n\n  return mash;\n}\n\nfunction copy(f, t) {\n  t.c = f.c;\n  t.s0 = f.s0;\n  t.s1 = f.s1;\n  t.s2 = f.s2;\n  return t;\n}\n\nfunction alea(seed, state) {\n  const xg = new Alea(seed);\n  const prng = xg.next.bind(xg);\n  if (state) copy(state, xg);\n\n  prng.state = () => copy(xg, {});\n\n  return prng;\n}\n/*\r\n * Copyright 2017 The boardgame.io Authors\r\n *\r\n * Use of this source code is governed by a MIT-style\r\n * license that can be found in the LICENSE file or at\r\n * https://opensource.org/licenses/MIT.\r\n */\n\n/**\r\n * Random\r\n *\r\n * Calls that require a pseudorandom number generator.\r\n * Uses a seed from ctx, and also persists the PRNG\r\n * state in ctx so that moves can stay pure.\r\n */\n\n\nclass Random {\n  /**\r\n   * constructor\r\n   * @param {object} ctx - The ctx object to initialize from.\r\n   */\n  constructor(state) {\n    // If we are on the client, the seed is not present.\n    // Just use a temporary seed to execute the move without\n    // crashing it. The move state itself is discarded,\n    // so the actual value doesn't matter.\n    this.state = state || {\n      seed: '0'\n    };\n    this.used = false;\n  }\n  /**\r\n   * Generates a new seed from the current date / time.\r\n   */\n\n\n  static seed() {\n    return Date.now().toString(36).slice(-10);\n  }\n\n  isUsed() {\n    return this.used;\n  }\n\n  getState() {\n    return this.state;\n  }\n  /**\r\n   * Generate a random number.\r\n   */\n\n\n  _random() {\n    this.used = true;\n    const R = this.state;\n    const seed = R.prngstate ? '' : R.seed;\n    const rand = alea(seed, R.prngstate);\n    const number = rand();\n    this.state = { ...R,\n      prngstate: rand.state()\n    };\n    return number;\n  }\n\n  api() {\n    const random = this._random.bind(this);\n\n    const SpotValue = {\n      D4: 4,\n      D6: 6,\n      D8: 8,\n      D10: 10,\n      D12: 12,\n      D20: 20\n    }; // Generate functions for predefined dice values D4 - D20.\n\n    const predefined = {};\n\n    for (const key in SpotValue) {\n      const spotvalue = SpotValue[key];\n\n      predefined[key] = diceCount => {\n        return diceCount === undefined ? Math.floor(random() * spotvalue) + 1 : [...new Array(diceCount).keys()].map(() => Math.floor(random() * spotvalue) + 1);\n      };\n    }\n\n    function Die(spotvalue = 6, diceCount) {\n      return diceCount === undefined ? Math.floor(random() * spotvalue) + 1 : [...new Array(diceCount).keys()].map(() => Math.floor(random() * spotvalue) + 1);\n    }\n\n    return {\n      /**\r\n       * Similar to Die below, but with fixed spot values.\r\n       * Supports passing a diceCount\r\n       *    if not defined, defaults to 1 and returns the value directly.\r\n       *    if defined, returns an array containing the random dice values.\r\n       *\r\n       * D4: (diceCount) => value\r\n       * D6: (diceCount) => value\r\n       * D8: (diceCount) => value\r\n       * D10: (diceCount) => value\r\n       * D12: (diceCount) => value\r\n       * D20: (diceCount) => value\r\n       */\n      ...predefined,\n\n      /**\r\n       * Roll a die of specified spot value.\r\n       *\r\n       * @param {number} spotvalue - The die dimension (default: 6).\r\n       * @param {number} diceCount - number of dice to throw.\r\n       *                             if not defined, defaults to 1 and returns the value directly.\r\n       *                             if defined, returns an array containing the random dice values.\r\n       */\n      Die,\n\n      /**\r\n       * Generate a random number between 0 and 1.\r\n       */\n      Number: () => {\n        return random();\n      },\n\n      /**\r\n       * Shuffle an array.\r\n       *\r\n       * @param {Array} deck - The array to shuffle. Does not mutate\r\n       *                       the input, but returns the shuffled array.\r\n       */\n      Shuffle: deck => {\n        const clone = deck.slice(0);\n        let srcIndex = deck.length;\n        let dstIndex = 0;\n        const shuffled = new Array(srcIndex);\n\n        while (srcIndex) {\n          const randIndex = Math.trunc(srcIndex * random());\n          shuffled[dstIndex++] = clone[randIndex];\n          clone[randIndex] = clone[--srcIndex];\n        }\n\n        return shuffled;\n      },\n      _obj: this\n    };\n  }\n\n}\n/*\r\n * Copyright 2018 The boardgame.io Authors\r\n *\r\n * Use of this source code is governed by a MIT-style\r\n * license that can be found in the LICENSE file or at\r\n * https://opensource.org/licenses/MIT.\r\n */\n\n\nconst RandomPlugin = {\n  name: 'random',\n  noClient: ({\n    api\n  }) => {\n    return api._obj.isUsed();\n  },\n  flush: ({\n    api\n  }) => {\n    return api._obj.getState();\n  },\n  api: ({\n    data\n  }) => {\n    const random = new Random(data);\n    return random.api();\n  },\n  setup: ({\n    game\n  }) => {\n    let {\n      seed\n    } = game;\n\n    if (seed === undefined) {\n      seed = Random.seed();\n    }\n\n    return {\n      seed\n    };\n  },\n  playerView: () => undefined\n};\n/*\r\n * Copyright 2018 The boardgame.io Authors\r\n *\r\n * Use of this source code is governed by a MIT-style\r\n * license that can be found in the LICENSE file or at\r\n * https://opensource.org/licenses/MIT.\r\n */\n\n/**\r\n * Events\r\n */\n\nclass Events {\n  constructor(flow, playerID) {\n    this.flow = flow;\n    this.playerID = playerID;\n    this.dispatch = [];\n  }\n  /**\r\n   * Attaches the Events API to ctx.\r\n   * @param {object} ctx - The ctx object to attach to.\r\n   */\n\n\n  api(ctx) {\n    const events = {\n      _obj: this\n    };\n    const {\n      phase,\n      turn\n    } = ctx;\n\n    for (const key of this.flow.eventNames) {\n      events[key] = (...args) => {\n        this.dispatch.push({\n          key,\n          args,\n          phase,\n          turn\n        });\n      };\n    }\n\n    return events;\n  }\n\n  isUsed() {\n    return this.dispatch.length > 0;\n  }\n  /**\r\n   * Updates ctx with the triggered events.\r\n   * @param {object} state - The state object { G, ctx }.\r\n   */\n\n\n  update(state) {\n    for (let i = 0; i < this.dispatch.length; i++) {\n      const item = this.dispatch[i]; // If the turn already ended some other way,\n      // don't try to end the turn again.\n\n      if (item.key === 'endTurn' && item.turn !== state.ctx.turn) {\n        continue;\n      } // If the phase already ended some other way,\n      // don't try to end the phase again.\n\n\n      if ((item.key === 'endPhase' || item.key === 'setPhase') && item.phase !== state.ctx.phase) {\n        continue;\n      }\n\n      const action = automaticGameEvent(item.key, item.args, this.playerID);\n      state = { ...state,\n        ...this.flow.processEvent(state, action)\n      };\n    }\n\n    return state;\n  }\n\n}\n/*\r\n * Copyright 2020 The boardgame.io Authors\r\n *\r\n * Use of this source code is governed by a MIT-style\r\n * license that can be found in the LICENSE file or at\r\n * https://opensource.org/licenses/MIT.\r\n */\n\n\nconst EventsPlugin = {\n  name: 'events',\n  noClient: ({\n    api\n  }) => {\n    return api._obj.isUsed();\n  },\n  dangerouslyFlushRawState: ({\n    state,\n    api\n  }) => {\n    return api._obj.update(state);\n  },\n  api: ({\n    game,\n    playerID,\n    ctx\n  }) => {\n    return new Events(game.flow, playerID).api(ctx);\n  }\n};\n/*\r\n * Copyright 2018 The boardgame.io Authors\r\n *\r\n * Use of this source code is governed by a MIT-style\r\n * license that can be found in the LICENSE file or at\r\n * https://opensource.org/licenses/MIT.\r\n */\n\n/**\r\n * Plugin that makes it possible to add metadata to log entries.\r\n * During a move, you can set metadata using ctx.log.setMetadata and it will be\r\n * available on the log entry for that move.\r\n */\n\nconst LogPlugin = {\n  name: 'log',\n  flush: () => ({}),\n  api: ({\n    data\n  }) => {\n    return {\n      setMetadata: metadata => {\n        data.metadata = metadata;\n      }\n    };\n  },\n  setup: () => ({})\n};\n/**\r\n * Check if a value can be serialized (e.g. using `JSON.stringify`).\r\n * Adapted from: https://stackoverflow.com/a/30712764/3829557\r\n */\n\nfunction isSerializable(value) {\n  // Primitives are OK.\n  if (value === undefined || value === null || typeof value === 'boolean' || typeof value === 'number' || typeof value === 'string') {\n    return true;\n  } // A non-primitive value that is neither a POJO or an array cannot be serialized.\n\n\n  if (!isPlainObject(value) && !Array.isArray(value)) {\n    return false;\n  } // Recurse entries if the value is an object or array.\n\n\n  for (const key in value) {\n    if (!isSerializable(value[key])) return false;\n  }\n\n  return true;\n}\n/**\r\n * Plugin that checks whether state is serializable, in order to avoid\r\n * network serialization bugs.\r\n */\n\n\nconst SerializablePlugin = {\n  name: 'plugin-serializable',\n  fnWrap: move => (G, ctx, ...args) => {\n    const result = move(G, ctx, ...args); // Check state in non-production environments.\n\n    if (process.env.NODE_ENV !== 'production' && !isSerializable(result)) {\n      throw new Error('Move state is not JSON-serialiazable.\\n' + 'See https://boardgame.io/documentation/#/?id=state for more information.');\n    }\n\n    return result;\n  }\n};\n/*\r\n * Copyright 2018 The boardgame.io Authors\r\n *\r\n * Use of this source code is governed by a MIT-style\r\n * license that can be found in the LICENSE file or at\r\n * https://opensource.org/licenses/MIT.\r\n */\n\n/**\r\n * List of plugins that are always added.\r\n */\n\nconst CORE_PLUGINS = [ImmerPlugin, RandomPlugin, LogPlugin, SerializablePlugin];\nconst DEFAULT_PLUGINS = [...CORE_PLUGINS, EventsPlugin];\n/**\r\n * Allow plugins to intercept actions and process them.\r\n */\n\nconst ProcessAction = (state, action, opts) => {\n  // TODO(#723): Extend error handling to plugins.\n  opts.game.plugins.filter(plugin => plugin.action !== undefined).filter(plugin => plugin.name === action.payload.type).forEach(plugin => {\n    const name = plugin.name;\n    const pluginState = state.plugins[name] || {\n      data: {}\n    };\n    const data = plugin.action(pluginState.data, action.payload);\n    state = { ...state,\n      plugins: { ...state.plugins,\n        [name]: { ...pluginState,\n          data\n        }\n      }\n    };\n  });\n  return state;\n};\n/**\r\n * The API's created by various plugins are stored in the plugins\r\n * section of the state object:\r\n *\r\n * {\r\n *   G: {},\r\n *   ctx: {},\r\n *   plugins: {\r\n *     plugin-a: {\r\n *       data: {},  // this is generated by the plugin at Setup / Flush.\r\n *       api: {},   // this is ephemeral and generated by Enhance.\r\n *     }\r\n *   }\r\n * }\r\n *\r\n * This function takes these API's and stuffs them back into\r\n * ctx for consumption inside a move function or hook.\r\n */\n\n\nconst EnhanceCtx = state => {\n  const ctx = { ...state.ctx\n  };\n  const plugins = state.plugins || {};\n  Object.entries(plugins).forEach(([name, {\n    api\n  }]) => {\n    ctx[name] = api;\n  });\n  return ctx;\n};\n/**\r\n * Applies the provided plugins to the given move / flow function.\r\n *\r\n * @param {function} fn - The move function or trigger to apply the plugins to.\r\n * @param {object} plugins - The list of plugins.\r\n */\n\n\nconst FnWrap = (fn, plugins) => {\n  const reducer = (acc, {\n    fnWrap\n  }) => fnWrap(acc);\n\n  return [...DEFAULT_PLUGINS, ...plugins].filter(plugin => plugin.fnWrap !== undefined).reduce(reducer, fn);\n};\n/**\r\n * Allows the plugin to generate its initial state.\r\n */\n\n\nconst Setup = (state, opts) => {\n  [...DEFAULT_PLUGINS, ...opts.game.plugins].filter(plugin => plugin.setup !== undefined).forEach(plugin => {\n    const name = plugin.name;\n    const data = plugin.setup({\n      G: state.G,\n      ctx: state.ctx,\n      game: opts.game\n    });\n    state = { ...state,\n      plugins: { ...state.plugins,\n        [name]: {\n          data\n        }\n      }\n    };\n  });\n  return state;\n};\n/**\r\n * Invokes the plugin before a move or event.\r\n * The API that the plugin generates is stored inside\r\n * the `plugins` section of the state (which is subsequently\r\n * merged into ctx).\r\n */\n\n\nconst Enhance = (state, opts) => {\n  [...DEFAULT_PLUGINS, ...opts.game.plugins].filter(plugin => plugin.api !== undefined).forEach(plugin => {\n    const name = plugin.name;\n    const pluginState = state.plugins[name] || {\n      data: {}\n    };\n    const api = plugin.api({\n      G: state.G,\n      ctx: state.ctx,\n      data: pluginState.data,\n      game: opts.game,\n      playerID: opts.playerID\n    });\n    state = { ...state,\n      plugins: { ...state.plugins,\n        [name]: { ...pluginState,\n          api\n        }\n      }\n    };\n  });\n  return state;\n};\n/**\r\n * Allows plugins to update their state after a move / event.\r\n */\n\n\nconst Flush = (state, opts) => {\n  // We flush the events plugin first, then custom plugins and the core plugins.\n  // This means custom plugins cannot use the events API but will be available in event hooks.\n  // Note that plugins are flushed in reverse, to allow custom plugins calling each other.\n  [...CORE_PLUGINS, ...opts.game.plugins, EventsPlugin].reverse().forEach(plugin => {\n    const name = plugin.name;\n    const pluginState = state.plugins[name] || {\n      data: {}\n    };\n\n    if (plugin.flush) {\n      const newData = plugin.flush({\n        G: state.G,\n        ctx: state.ctx,\n        game: opts.game,\n        api: pluginState.api,\n        data: pluginState.data\n      });\n      state = { ...state,\n        plugins: { ...state.plugins,\n          [plugin.name]: {\n            data: newData\n          }\n        }\n      };\n    } else if (plugin.dangerouslyFlushRawState) {\n      state = plugin.dangerouslyFlushRawState({\n        state,\n        game: opts.game,\n        api: pluginState.api,\n        data: pluginState.data\n      }); // Remove everything other than data.\n\n      const data = state.plugins[name].data;\n      state = { ...state,\n        plugins: { ...state.plugins,\n          [plugin.name]: {\n            data\n          }\n        }\n      };\n    }\n  });\n  return state;\n};\n/**\r\n * Allows plugins to indicate if they should not be materialized on the client.\r\n * This will cause the client to discard the state update and wait for the\r\n * master instead.\r\n */\n\n\nconst NoClient = (state, opts) => {\n  return [...DEFAULT_PLUGINS, ...opts.game.plugins].filter(plugin => plugin.noClient !== undefined).map(plugin => {\n    const name = plugin.name;\n    const pluginState = state.plugins[name];\n\n    if (pluginState) {\n      return plugin.noClient({\n        G: state.G,\n        ctx: state.ctx,\n        game: opts.game,\n        api: pluginState.api,\n        data: pluginState.data\n      });\n    }\n\n    return false;\n  }).some(value => value === true);\n};\n/**\r\n * Allows plugins to customize their data for specific players.\r\n * For example, a plugin may want to share no data with the client, or\r\n * want to keep some player data secret from opponents.\r\n */\n\n\nconst PlayerView = ({\n  G,\n  ctx,\n  plugins = {}\n}, {\n  game,\n  playerID\n}) => {\n  [...DEFAULT_PLUGINS, ...game.plugins].forEach(({\n    name,\n    playerView\n  }) => {\n    if (!playerView) return;\n    const {\n      data\n    } = plugins[name] || {\n      data: {}\n    };\n    const newData = playerView({\n      G,\n      ctx,\n      game,\n      data,\n      playerID\n    });\n    plugins = { ...plugins,\n      [name]: {\n        data: newData\n      }\n    };\n  });\n  return plugins;\n};\n/*\r\n * Copyright 2018 The boardgame.io Authors\r\n *\r\n * Use of this source code is governed by a MIT-style\r\n * license that can be found in the LICENSE file or at\r\n * https://opensource.org/licenses/MIT.\r\n */\n\n\nconst production = process.env.NODE_ENV === 'production';\nconst logfn = production ? () => {} : (...msg) => console.log(...msg);\n\nconst errorfn = (...msg) => console.error(...msg);\n\nfunction info(msg) {\n  logfn(`INFO: ${msg}`);\n}\n\nfunction error(error) {\n  errorfn('ERROR:', error);\n}\n/*\r\n * Copyright 2017 The boardgame.io Authors\r\n *\r\n * Use of this source code is governed by a MIT-style\r\n * license that can be found in the LICENSE file or at\r\n * https://opensource.org/licenses/MIT.\r\n */\n\n/**\r\n * Event to change the active players (and their stages) in the current turn.\r\n */\n\n\nfunction SetActivePlayersEvent(state, _playerID, arg) {\n  return { ...state,\n    ctx: SetActivePlayers(state.ctx, arg)\n  };\n}\n\nfunction SetActivePlayers(ctx, arg) {\n  let {\n    _prevActivePlayers\n  } = ctx;\n  let activePlayers = {};\n  let _nextActivePlayers = null;\n  let _activePlayersMoveLimit = {};\n\n  if (Array.isArray(arg)) {\n    // support a simple array of player IDs as active players\n    const value = {};\n    arg.forEach(v => value[v] = Stage.NULL);\n    activePlayers = value;\n  } else {\n    // process active players argument object\n    if (arg.next) {\n      _nextActivePlayers = arg.next;\n    }\n\n    _prevActivePlayers = arg.revert ? _prevActivePlayers.concat({\n      activePlayers: ctx.activePlayers,\n      _activePlayersMoveLimit: ctx._activePlayersMoveLimit,\n      _activePlayersNumMoves: ctx._activePlayersNumMoves\n    }) : [];\n\n    if (arg.currentPlayer !== undefined) {\n      ApplyActivePlayerArgument(activePlayers, _activePlayersMoveLimit, ctx.currentPlayer, arg.currentPlayer);\n    }\n\n    if (arg.others !== undefined) {\n      for (let i = 0; i < ctx.playOrder.length; i++) {\n        const id = ctx.playOrder[i];\n\n        if (id !== ctx.currentPlayer) {\n          ApplyActivePlayerArgument(activePlayers, _activePlayersMoveLimit, id, arg.others);\n        }\n      }\n    }\n\n    if (arg.all !== undefined) {\n      for (let i = 0; i < ctx.playOrder.length; i++) {\n        const id = ctx.playOrder[i];\n        ApplyActivePlayerArgument(activePlayers, _activePlayersMoveLimit, id, arg.all);\n      }\n    }\n\n    if (arg.value) {\n      for (const id in arg.value) {\n        ApplyActivePlayerArgument(activePlayers, _activePlayersMoveLimit, id, arg.value[id]);\n      }\n    }\n\n    if (arg.moveLimit) {\n      for (const id in activePlayers) {\n        if (_activePlayersMoveLimit[id] === undefined) {\n          _activePlayersMoveLimit[id] = arg.moveLimit;\n        }\n      }\n    }\n  }\n\n  if (Object.keys(activePlayers).length == 0) {\n    activePlayers = null;\n  }\n\n  if (Object.keys(_activePlayersMoveLimit).length == 0) {\n    _activePlayersMoveLimit = null;\n  }\n\n  const _activePlayersNumMoves = {};\n\n  for (const id in activePlayers) {\n    _activePlayersNumMoves[id] = 0;\n  }\n\n  return { ...ctx,\n    activePlayers,\n    _activePlayersMoveLimit,\n    _activePlayersNumMoves,\n    _prevActivePlayers,\n    _nextActivePlayers\n  };\n}\n/**\r\n * Update activePlayers, setting it to previous, next or null values\r\n * when it becomes empty.\r\n * @param ctx\r\n */\n\n\nfunction UpdateActivePlayersOnceEmpty(ctx) {\n  let {\n    activePlayers,\n    _activePlayersMoveLimit,\n    _activePlayersNumMoves,\n    _prevActivePlayers\n  } = ctx;\n\n  if (activePlayers && Object.keys(activePlayers).length == 0) {\n    if (ctx._nextActivePlayers) {\n      ctx = SetActivePlayers(ctx, ctx._nextActivePlayers);\n      ({\n        activePlayers,\n        _activePlayersMoveLimit,\n        _activePlayersNumMoves,\n        _prevActivePlayers\n      } = ctx);\n    } else if (_prevActivePlayers.length > 0) {\n      const lastIndex = _prevActivePlayers.length - 1;\n      ({\n        activePlayers,\n        _activePlayersMoveLimit,\n        _activePlayersNumMoves\n      } = _prevActivePlayers[lastIndex]);\n      _prevActivePlayers = _prevActivePlayers.slice(0, lastIndex);\n    } else {\n      activePlayers = null;\n      _activePlayersMoveLimit = null;\n    }\n  }\n\n  return { ...ctx,\n    activePlayers,\n    _activePlayersMoveLimit,\n    _activePlayersNumMoves,\n    _prevActivePlayers\n  };\n}\n/**\r\n * Apply an active player argument to the given player ID\r\n * @param {Object} activePlayers\r\n * @param {Object} _activePlayersMoveLimit\r\n * @param {String} playerID The player to apply the parameter to\r\n * @param {(String|Object)} arg An active player argument\r\n */\n\n\nfunction ApplyActivePlayerArgument(activePlayers, _activePlayersMoveLimit, playerID, arg) {\n  if (typeof arg !== 'object' || arg === Stage.NULL) {\n    arg = {\n      stage: arg\n    };\n  }\n\n  if (arg.stage !== undefined) {\n    activePlayers[playerID] = arg.stage;\n    if (arg.moveLimit) _activePlayersMoveLimit[playerID] = arg.moveLimit;\n  }\n}\n/**\r\n * Converts a playOrderPos index into its value in playOrder.\r\n * @param {Array} playOrder - An array of player ID's.\r\n * @param {number} playOrderPos - An index into the above.\r\n */\n\n\nfunction getCurrentPlayer(playOrder, playOrderPos) {\n  // convert to string in case playOrder is set to number[]\n  return playOrder[playOrderPos] + '';\n}\n/**\r\n * Called at the start of a turn to initialize turn order state.\r\n *\r\n * TODO: This is called inside StartTurn, which is called from\r\n * both UpdateTurn and StartPhase (so it's called at the beginning\r\n * of a new phase as well as between turns). We should probably\r\n * split it into two.\r\n */\n\n\nfunction InitTurnOrderState(state, turn) {\n  let {\n    G,\n    ctx\n  } = state;\n  const ctxWithAPI = EnhanceCtx(state);\n  const order = turn.order;\n  let playOrder = [...new Array(ctx.numPlayers)].map((_, i) => i + '');\n\n  if (order.playOrder !== undefined) {\n    playOrder = order.playOrder(G, ctxWithAPI);\n  }\n\n  const playOrderPos = order.first(G, ctxWithAPI);\n  const posType = typeof playOrderPos;\n\n  if (posType !== 'number') {\n    error(`invalid value returned by turn.order.first — expected number got ${posType} “${playOrderPos}”.`);\n  }\n\n  const currentPlayer = getCurrentPlayer(playOrder, playOrderPos);\n  ctx = { ...ctx,\n    currentPlayer,\n    playOrderPos,\n    playOrder\n  };\n  ctx = SetActivePlayers(ctx, turn.activePlayers || {});\n  return ctx;\n}\n/**\r\n * Called at the end of each turn to update the turn order state.\r\n * @param {object} G - The game object G.\r\n * @param {object} ctx - The game object ctx.\r\n * @param {object} turn - A turn object for this phase.\r\n * @param {string} endTurnArg - An optional argument to endTurn that\r\n                                may specify the next player.\r\n */\n\n\nfunction UpdateTurnOrderState(state, currentPlayer, turn, endTurnArg) {\n  const order = turn.order;\n  let {\n    G,\n    ctx\n  } = state;\n  let playOrderPos = ctx.playOrderPos;\n  let endPhase = false;\n\n  if (endTurnArg && endTurnArg !== true) {\n    if (typeof endTurnArg !== 'object') {\n      error(`invalid argument to endTurn: ${endTurnArg}`);\n    }\n\n    Object.keys(endTurnArg).forEach(arg => {\n      switch (arg) {\n        case 'remove':\n          currentPlayer = getCurrentPlayer(ctx.playOrder, playOrderPos);\n          break;\n\n        case 'next':\n          playOrderPos = ctx.playOrder.indexOf(endTurnArg.next);\n          currentPlayer = endTurnArg.next;\n          break;\n\n        default:\n          error(`invalid argument to endTurn: ${arg}`);\n      }\n    });\n  } else {\n    const ctxWithAPI = EnhanceCtx(state);\n    const t = order.next(G, ctxWithAPI);\n    const type = typeof t;\n\n    if (t !== undefined && type !== 'number') {\n      error(`invalid value returned by turn.order.next — expected number or undefined got ${type} “${t}”.`);\n    }\n\n    if (t === undefined) {\n      endPhase = true;\n    } else {\n      playOrderPos = t;\n      currentPlayer = getCurrentPlayer(ctx.playOrder, playOrderPos);\n    }\n  }\n\n  ctx = { ...ctx,\n    playOrderPos,\n    currentPlayer\n  };\n  return {\n    endPhase,\n    ctx\n  };\n}\n/**\r\n * Set of different turn orders possible in a phase.\r\n * These are meant to be passed to the `turn` setting\r\n * in the flow objects.\r\n *\r\n * Each object defines the first player when the phase / game\r\n * begins, and also a function `next` to determine who the\r\n * next player is when the turn ends.\r\n *\r\n * The phase ends if next() returns undefined.\r\n */\n\n\nconst TurnOrder = {\n  /**\r\n   * DEFAULT\r\n   *\r\n   * The default round-robin turn order.\r\n   */\n  DEFAULT: {\n    first: (G, ctx) => ctx.turn === 0 ? ctx.playOrderPos : (ctx.playOrderPos + 1) % ctx.playOrder.length,\n    next: (G, ctx) => (ctx.playOrderPos + 1) % ctx.playOrder.length\n  },\n\n  /**\r\n   * RESET\r\n   *\r\n   * Similar to DEFAULT, but starts from 0 each time.\r\n   */\n  RESET: {\n    first: () => 0,\n    next: (G, ctx) => (ctx.playOrderPos + 1) % ctx.playOrder.length\n  },\n\n  /**\r\n   * CONTINUE\r\n   *\r\n   * Similar to DEFAULT, but starts with the player who ended the last phase.\r\n   */\n  CONTINUE: {\n    first: (G, ctx) => ctx.playOrderPos,\n    next: (G, ctx) => (ctx.playOrderPos + 1) % ctx.playOrder.length\n  },\n\n  /**\r\n   * ONCE\r\n   *\r\n   * Another round-robin turn order, but goes around just once.\r\n   * The phase ends after all players have played.\r\n   */\n  ONCE: {\n    first: () => 0,\n    next: (G, ctx) => {\n      if (ctx.playOrderPos < ctx.playOrder.length - 1) {\n        return ctx.playOrderPos + 1;\n      }\n    }\n  },\n\n  /**\r\n   * CUSTOM\r\n   *\r\n   * Identical to DEFAULT, but also sets playOrder at the\r\n   * beginning of the phase.\r\n   *\r\n   * @param {Array} playOrder - The play order.\r\n   */\n  CUSTOM: playOrder => ({\n    playOrder: () => playOrder,\n    first: () => 0,\n    next: (G, ctx) => (ctx.playOrderPos + 1) % ctx.playOrder.length\n  }),\n\n  /**\r\n   * CUSTOM_FROM\r\n   *\r\n   * Identical to DEFAULT, but also sets playOrder at the\r\n   * beginning of the phase to a value specified by a field\r\n   * in G.\r\n   *\r\n   * @param {string} playOrderField - Field in G.\r\n   */\n  CUSTOM_FROM: playOrderField => ({\n    playOrder: G => G[playOrderField],\n    first: () => 0,\n    next: (G, ctx) => (ctx.playOrderPos + 1) % ctx.playOrder.length\n  })\n};\nconst Stage = {\n  NULL: null\n};\nconst ActivePlayers = {\n  /**\r\n   * ALL\r\n   *\r\n   * The turn stays with one player, but any player can play (in any order)\r\n   * until the phase ends.\r\n   */\n  ALL: {\n    all: Stage.NULL\n  },\n\n  /**\r\n   * ALL_ONCE\r\n   *\r\n   * The turn stays with one player, but any player can play (once, and in any order).\r\n   * This is typically used in a phase where you want to elicit a response\r\n   * from every player in the game.\r\n   */\n  ALL_ONCE: {\n    all: Stage.NULL,\n    moveLimit: 1\n  },\n\n  /**\r\n   * OTHERS\r\n   *\r\n   * The turn stays with one player, and every *other* player can play (in any order)\r\n   * until the phase ends.\r\n   */\n  OTHERS: {\n    others: Stage.NULL\n  },\n\n  /**\r\n   * OTHERS_ONCE\r\n   *\r\n   * The turn stays with one player, and every *other* player can play (once, and in any order).\r\n   * This is typically used in a phase where you want to elicit a response\r\n   * from every *other* player in the game.\r\n   */\n  OTHERS_ONCE: {\n    others: Stage.NULL,\n    moveLimit: 1\n  }\n};\nexport { ActionCreators as A, update as B, patch as C, EnhanceCtx as E, FnWrap as F, GAME_EVENT as G, InitTurnOrderState as I, MAKE_MOVE as M, NoClient as N, PLUGIN as P, RESET as R, Stage as S, TurnOrder as T, UpdateTurnOrderState as U, SetActivePlayersEvent as a, SetActivePlayers as b, UpdateActivePlayersOnceEmpty as c, STRIP_TRANSIENTS as d, error as e, Enhance as f, gameEvent as g, Flush as h, info as i, INVALID_MOVE as j, UPDATE as k, SYNC as l, UNDO as m, REDO as n, ProcessAction as o, PATCH as p, stripTransients as q, Setup as r, sync as s, reset as t, undo as u, redo as v, PlayerView as w, makeMove as x, alea as y, ActivePlayers as z };","map":{"version":3,"sources":["/Users/goldenowl/Desktop/example-boardgame/node_modules/boardgame.io/dist/esm/turn-order-62966a9c.js"],"names":["produce","isPlainObject","MAKE_MOVE","GAME_EVENT","REDO","RESET","SYNC","UNDO","UPDATE","PATCH","PLUGIN","STRIP_TRANSIENTS","makeMove","type","args","playerID","credentials","payload","gameEvent","automaticGameEvent","automatic","sync","info","state","log","initialState","clientOnly","patch","prevStateID","stateID","deltalog","update","reset","undo","redo","plugin","stripTransients","ActionCreators","Object","freeze","INVALID_MOVE","ImmerPlugin","name","fnWrap","move","G","ctx","isInvalid","newG","result","Alea","constructor","seed","mash","Mash","c","s0","s1","s2","next","t","Math","trunc","n","data","str","toString","i","length","charCodeAt","h","copy","f","alea","xg","prng","bind","Random","used","Date","now","slice","isUsed","getState","_random","R","prngstate","rand","number","api","random","SpotValue","D4","D6","D8","D10","D12","D20","predefined","key","spotvalue","diceCount","undefined","floor","Array","keys","map","Die","Number","Shuffle","deck","clone","srcIndex","dstIndex","shuffled","randIndex","_obj","RandomPlugin","noClient","flush","setup","game","playerView","Events","flow","dispatch","events","phase","turn","eventNames","push","item","action","processEvent","EventsPlugin","dangerouslyFlushRawState","LogPlugin","setMetadata","metadata","isSerializable","value","isArray","SerializablePlugin","process","env","NODE_ENV","Error","CORE_PLUGINS","DEFAULT_PLUGINS","ProcessAction","opts","plugins","filter","forEach","pluginState","EnhanceCtx","entries","FnWrap","fn","reducer","acc","reduce","Setup","Enhance","Flush","reverse","newData","NoClient","some","PlayerView","production","logfn","msg","console","errorfn","error","SetActivePlayersEvent","_playerID","arg","SetActivePlayers","_prevActivePlayers","activePlayers","_nextActivePlayers","_activePlayersMoveLimit","v","Stage","NULL","revert","concat","_activePlayersNumMoves","currentPlayer","ApplyActivePlayerArgument","others","playOrder","id","all","moveLimit","UpdateActivePlayersOnceEmpty","lastIndex","stage","getCurrentPlayer","playOrderPos","InitTurnOrderState","ctxWithAPI","order","numPlayers","_","first","posType","UpdateTurnOrderState","endTurnArg","endPhase","indexOf","TurnOrder","DEFAULT","CONTINUE","ONCE","CUSTOM","CUSTOM_FROM","playOrderField","ActivePlayers","ALL","ALL_ONCE","OTHERS","OTHERS_ONCE","A","B","C","E","F","I","M","N","P","S","T","U","a","b","d","e","g","j","k","l","m","o","p","q","r","s","u","w","x","y","z"],"mappings":"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","sourcesContent":["import produce from 'immer';\nimport isPlainObject from 'lodash.isplainobject';\n\n/*\r\n * Copyright 2017 The boardgame.io Authors\r\n *\r\n * Use of this source code is governed by a MIT-style\r\n * license that can be found in the LICENSE file or at\r\n * https://opensource.org/licenses/MIT.\r\n */\r\nconst MAKE_MOVE = 'MAKE_MOVE';\r\nconst GAME_EVENT = 'GAME_EVENT';\r\nconst REDO = 'REDO';\r\nconst RESET = 'RESET';\r\nconst SYNC = 'SYNC';\r\nconst UNDO = 'UNDO';\r\nconst UPDATE = 'UPDATE';\r\nconst PATCH = 'PATCH';\r\nconst PLUGIN = 'PLUGIN';\r\nconst STRIP_TRANSIENTS = 'STRIP_TRANSIENTS';\n\n/*\r\n * Copyright 2017 The boardgame.io Authors\r\n *\r\n * Use of this source code is governed by a MIT-style\r\n * license that can be found in the LICENSE file or at\r\n * https://opensource.org/licenses/MIT.\r\n */\r\n/**\r\n * Generate a move to be dispatched to the game move reducer.\r\n *\r\n * @param {string} type - The move type.\r\n * @param {Array}  args - Additional arguments.\r\n * @param {string}  playerID - The ID of the player making this action.\r\n * @param {string}  credentials - (optional) The credentials for the player making this action.\r\n */\r\nconst makeMove = (type, args, playerID, credentials) => ({\r\n    type: MAKE_MOVE,\r\n    payload: { type, args, playerID, credentials },\r\n});\r\n/**\r\n * Generate a game event to be dispatched to the flow reducer.\r\n *\r\n * @param {string} type - The event type.\r\n * @param {Array}  args - Additional arguments.\r\n * @param {string}  playerID - The ID of the player making this action.\r\n * @param {string}  credentials - (optional) The credentials for the player making this action.\r\n */\r\nconst gameEvent = (type, args, playerID, credentials) => ({\r\n    type: GAME_EVENT,\r\n    payload: { type, args, playerID, credentials },\r\n});\r\n/**\r\n * Generate an automatic game event that is a side-effect of a move.\r\n * @param {string} type - The event type.\r\n * @param {Array}  args - Additional arguments.\r\n * @param {string}  playerID - The ID of the player making this action.\r\n * @param {string}  credentials - (optional) The credentials for the player making this action.\r\n */\r\nconst automaticGameEvent = (type, args, playerID, credentials) => ({\r\n    type: GAME_EVENT,\r\n    payload: { type, args, playerID, credentials },\r\n    automatic: true,\r\n});\r\nconst sync = (info) => ({\r\n    type: SYNC,\r\n    state: info.state,\r\n    log: info.log,\r\n    initialState: info.initialState,\r\n    clientOnly: true,\r\n});\r\n/**\r\n * Used to update the Redux store's state with patch in response to\r\n * an action coming from another player.\r\n * @param prevStateID previous stateID\r\n * @param stateID stateID after this patch\r\n * @param {Operation[]} patch - The patch to apply.\r\n * @param {LogEntry[]} deltalog - A log delta.\r\n */\r\nconst patch = (prevStateID, stateID, patch, deltalog) => ({\r\n    type: PATCH,\r\n    prevStateID,\r\n    stateID,\r\n    patch,\r\n    deltalog,\r\n    clientOnly: true,\r\n});\r\n/**\r\n * Used to update the Redux store's state in response to\r\n * an action coming from another player.\r\n * @param {object} state - The state to restore.\r\n * @param {Array} deltalog - A log delta.\r\n */\r\nconst update = (state, deltalog) => ({\r\n    type: UPDATE,\r\n    state,\r\n    deltalog,\r\n    clientOnly: true,\r\n});\r\n/**\r\n * Used to reset the game state.\r\n * @param {object} state - The initial state.\r\n */\r\nconst reset = (state) => ({\r\n    type: RESET,\r\n    state,\r\n    clientOnly: true,\r\n});\r\n/**\r\n * Used to undo the last move.\r\n * @param {string}  playerID - The ID of the player making this action.\r\n * @param {string}  credentials - (optional) The credentials for the player making this action.\r\n */\r\nconst undo = (playerID, credentials) => ({\r\n    type: UNDO,\r\n    payload: { type: null, args: null, playerID, credentials },\r\n});\r\n/**\r\n * Used to redo the last undone move.\r\n * @param {string}  playerID - The ID of the player making this action.\r\n * @param {string}  credentials - (optional) The credentials for the player making this action.\r\n */\r\nconst redo = (playerID, credentials) => ({\r\n    type: REDO,\r\n    payload: { type: null, args: null, playerID, credentials },\r\n});\r\n/**\r\n * Allows plugins to define their own actions and intercept them.\r\n */\r\nconst plugin = (type, args, playerID, credentials) => ({\r\n    type: PLUGIN,\r\n    payload: { type, args, playerID, credentials },\r\n});\r\n/**\r\n * Private action used to strip transient metadata (e.g. errors) from the game\r\n * state.\r\n */\r\nconst stripTransients = () => ({\r\n    type: STRIP_TRANSIENTS,\r\n});\n\nvar ActionCreators = /*#__PURE__*/Object.freeze({\n  makeMove: makeMove,\n  gameEvent: gameEvent,\n  automaticGameEvent: automaticGameEvent,\n  sync: sync,\n  patch: patch,\n  update: update,\n  reset: reset,\n  undo: undo,\n  redo: redo,\n  plugin: plugin,\n  stripTransients: stripTransients\n});\n\n/**\r\n * Moves can return this when they want to indicate\r\n * that the combination of arguments is illegal and\r\n * the move ought to be discarded.\r\n */\r\nconst INVALID_MOVE = 'INVALID_MOVE';\n\n/*\r\n * Copyright 2018 The boardgame.io Authors\r\n *\r\n * Use of this source code is governed by a MIT-style\r\n * license that can be found in the LICENSE file or at\r\n * https://opensource.org/licenses/MIT.\r\n */\r\n/**\r\n * Plugin that allows using Immer to make immutable changes\r\n * to G by just mutating it.\r\n */\r\nconst ImmerPlugin = {\r\n    name: 'plugin-immer',\r\n    fnWrap: (move) => (G, ctx, ...args) => {\r\n        let isInvalid = false;\r\n        const newG = produce(G, (G) => {\r\n            const result = move(G, ctx, ...args);\r\n            if (result === INVALID_MOVE) {\r\n                isInvalid = true;\r\n                return;\r\n            }\r\n            return result;\r\n        });\r\n        if (isInvalid)\r\n            return INVALID_MOVE;\r\n        return newG;\r\n    },\r\n};\n\n// Inlined version of Alea from https://github.com/davidbau/seedrandom.\r\n// Converted to Typescript October 2020.\r\nclass Alea {\r\n    constructor(seed) {\r\n        const mash = Mash();\r\n        // Apply the seeding algorithm from Baagoe.\r\n        this.c = 1;\r\n        this.s0 = mash(' ');\r\n        this.s1 = mash(' ');\r\n        this.s2 = mash(' ');\r\n        this.s0 -= mash(seed);\r\n        if (this.s0 < 0) {\r\n            this.s0 += 1;\r\n        }\r\n        this.s1 -= mash(seed);\r\n        if (this.s1 < 0) {\r\n            this.s1 += 1;\r\n        }\r\n        this.s2 -= mash(seed);\r\n        if (this.s2 < 0) {\r\n            this.s2 += 1;\r\n        }\r\n    }\r\n    next() {\r\n        const t = 2091639 * this.s0 + this.c * 2.3283064365386963e-10; // 2^-32\r\n        this.s0 = this.s1;\r\n        this.s1 = this.s2;\r\n        return (this.s2 = t - (this.c = Math.trunc(t)));\r\n    }\r\n}\r\nfunction Mash() {\r\n    let n = 0xefc8249d;\r\n    const mash = function (data) {\r\n        const str = data.toString();\r\n        for (let i = 0; i < str.length; i++) {\r\n            n += str.charCodeAt(i);\r\n            let h = 0.02519603282416938 * n;\r\n            n = h >>> 0;\r\n            h -= n;\r\n            h *= n;\r\n            n = h >>> 0;\r\n            h -= n;\r\n            n += h * 0x100000000; // 2^32\r\n        }\r\n        return (n >>> 0) * 2.3283064365386963e-10; // 2^-32\r\n    };\r\n    return mash;\r\n}\r\nfunction copy(f, t) {\r\n    t.c = f.c;\r\n    t.s0 = f.s0;\r\n    t.s1 = f.s1;\r\n    t.s2 = f.s2;\r\n    return t;\r\n}\r\nfunction alea(seed, state) {\r\n    const xg = new Alea(seed);\r\n    const prng = xg.next.bind(xg);\r\n    if (state)\r\n        copy(state, xg);\r\n    prng.state = () => copy(xg, {});\r\n    return prng;\r\n}\n\n/*\r\n * Copyright 2017 The boardgame.io Authors\r\n *\r\n * Use of this source code is governed by a MIT-style\r\n * license that can be found in the LICENSE file or at\r\n * https://opensource.org/licenses/MIT.\r\n */\r\n/**\r\n * Random\r\n *\r\n * Calls that require a pseudorandom number generator.\r\n * Uses a seed from ctx, and also persists the PRNG\r\n * state in ctx so that moves can stay pure.\r\n */\r\nclass Random {\r\n    /**\r\n     * constructor\r\n     * @param {object} ctx - The ctx object to initialize from.\r\n     */\r\n    constructor(state) {\r\n        // If we are on the client, the seed is not present.\r\n        // Just use a temporary seed to execute the move without\r\n        // crashing it. The move state itself is discarded,\r\n        // so the actual value doesn't matter.\r\n        this.state = state || { seed: '0' };\r\n        this.used = false;\r\n    }\r\n    /**\r\n     * Generates a new seed from the current date / time.\r\n     */\r\n    static seed() {\r\n        return Date.now().toString(36).slice(-10);\r\n    }\r\n    isUsed() {\r\n        return this.used;\r\n    }\r\n    getState() {\r\n        return this.state;\r\n    }\r\n    /**\r\n     * Generate a random number.\r\n     */\r\n    _random() {\r\n        this.used = true;\r\n        const R = this.state;\r\n        const seed = R.prngstate ? '' : R.seed;\r\n        const rand = alea(seed, R.prngstate);\r\n        const number = rand();\r\n        this.state = {\r\n            ...R,\r\n            prngstate: rand.state(),\r\n        };\r\n        return number;\r\n    }\r\n    api() {\r\n        const random = this._random.bind(this);\r\n        const SpotValue = {\r\n            D4: 4,\r\n            D6: 6,\r\n            D8: 8,\r\n            D10: 10,\r\n            D12: 12,\r\n            D20: 20,\r\n        };\r\n        // Generate functions for predefined dice values D4 - D20.\r\n        const predefined = {};\r\n        for (const key in SpotValue) {\r\n            const spotvalue = SpotValue[key];\r\n            predefined[key] = (diceCount) => {\r\n                return diceCount === undefined\r\n                    ? Math.floor(random() * spotvalue) + 1\r\n                    : [...new Array(diceCount).keys()].map(() => Math.floor(random() * spotvalue) + 1);\r\n            };\r\n        }\r\n        function Die(spotvalue = 6, diceCount) {\r\n            return diceCount === undefined\r\n                ? Math.floor(random() * spotvalue) + 1\r\n                : [...new Array(diceCount).keys()].map(() => Math.floor(random() * spotvalue) + 1);\r\n        }\r\n        return {\r\n            /**\r\n             * Similar to Die below, but with fixed spot values.\r\n             * Supports passing a diceCount\r\n             *    if not defined, defaults to 1 and returns the value directly.\r\n             *    if defined, returns an array containing the random dice values.\r\n             *\r\n             * D4: (diceCount) => value\r\n             * D6: (diceCount) => value\r\n             * D8: (diceCount) => value\r\n             * D10: (diceCount) => value\r\n             * D12: (diceCount) => value\r\n             * D20: (diceCount) => value\r\n             */\r\n            ...predefined,\r\n            /**\r\n             * Roll a die of specified spot value.\r\n             *\r\n             * @param {number} spotvalue - The die dimension (default: 6).\r\n             * @param {number} diceCount - number of dice to throw.\r\n             *                             if not defined, defaults to 1 and returns the value directly.\r\n             *                             if defined, returns an array containing the random dice values.\r\n             */\r\n            Die,\r\n            /**\r\n             * Generate a random number between 0 and 1.\r\n             */\r\n            Number: () => {\r\n                return random();\r\n            },\r\n            /**\r\n             * Shuffle an array.\r\n             *\r\n             * @param {Array} deck - The array to shuffle. Does not mutate\r\n             *                       the input, but returns the shuffled array.\r\n             */\r\n            Shuffle: (deck) => {\r\n                const clone = deck.slice(0);\r\n                let srcIndex = deck.length;\r\n                let dstIndex = 0;\r\n                const shuffled = new Array(srcIndex);\r\n                while (srcIndex) {\r\n                    const randIndex = Math.trunc(srcIndex * random());\r\n                    shuffled[dstIndex++] = clone[randIndex];\r\n                    clone[randIndex] = clone[--srcIndex];\r\n                }\r\n                return shuffled;\r\n            },\r\n            _obj: this,\r\n        };\r\n    }\r\n}\n\n/*\r\n * Copyright 2018 The boardgame.io Authors\r\n *\r\n * Use of this source code is governed by a MIT-style\r\n * license that can be found in the LICENSE file or at\r\n * https://opensource.org/licenses/MIT.\r\n */\r\nconst RandomPlugin = {\r\n    name: 'random',\r\n    noClient: ({ api }) => {\r\n        return api._obj.isUsed();\r\n    },\r\n    flush: ({ api }) => {\r\n        return api._obj.getState();\r\n    },\r\n    api: ({ data }) => {\r\n        const random = new Random(data);\r\n        return random.api();\r\n    },\r\n    setup: ({ game }) => {\r\n        let { seed } = game;\r\n        if (seed === undefined) {\r\n            seed = Random.seed();\r\n        }\r\n        return { seed };\r\n    },\r\n    playerView: () => undefined,\r\n};\n\n/*\r\n * Copyright 2018 The boardgame.io Authors\r\n *\r\n * Use of this source code is governed by a MIT-style\r\n * license that can be found in the LICENSE file or at\r\n * https://opensource.org/licenses/MIT.\r\n */\r\n/**\r\n * Events\r\n */\r\nclass Events {\r\n    constructor(flow, playerID) {\r\n        this.flow = flow;\r\n        this.playerID = playerID;\r\n        this.dispatch = [];\r\n    }\r\n    /**\r\n     * Attaches the Events API to ctx.\r\n     * @param {object} ctx - The ctx object to attach to.\r\n     */\r\n    api(ctx) {\r\n        const events = {\r\n            _obj: this,\r\n        };\r\n        const { phase, turn } = ctx;\r\n        for (const key of this.flow.eventNames) {\r\n            events[key] = (...args) => {\r\n                this.dispatch.push({ key, args, phase, turn });\r\n            };\r\n        }\r\n        return events;\r\n    }\r\n    isUsed() {\r\n        return this.dispatch.length > 0;\r\n    }\r\n    /**\r\n     * Updates ctx with the triggered events.\r\n     * @param {object} state - The state object { G, ctx }.\r\n     */\r\n    update(state) {\r\n        for (let i = 0; i < this.dispatch.length; i++) {\r\n            const item = this.dispatch[i];\r\n            // If the turn already ended some other way,\r\n            // don't try to end the turn again.\r\n            if (item.key === 'endTurn' && item.turn !== state.ctx.turn) {\r\n                continue;\r\n            }\r\n            // If the phase already ended some other way,\r\n            // don't try to end the phase again.\r\n            if ((item.key === 'endPhase' || item.key === 'setPhase') &&\r\n                item.phase !== state.ctx.phase) {\r\n                continue;\r\n            }\r\n            const action = automaticGameEvent(item.key, item.args, this.playerID);\r\n            state = {\r\n                ...state,\r\n                ...this.flow.processEvent(state, action),\r\n            };\r\n        }\r\n        return state;\r\n    }\r\n}\n\n/*\r\n * Copyright 2020 The boardgame.io Authors\r\n *\r\n * Use of this source code is governed by a MIT-style\r\n * license that can be found in the LICENSE file or at\r\n * https://opensource.org/licenses/MIT.\r\n */\r\nconst EventsPlugin = {\r\n    name: 'events',\r\n    noClient: ({ api }) => {\r\n        return api._obj.isUsed();\r\n    },\r\n    dangerouslyFlushRawState: ({ state, api }) => {\r\n        return api._obj.update(state);\r\n    },\r\n    api: ({ game, playerID, ctx }) => {\r\n        return new Events(game.flow, playerID).api(ctx);\r\n    },\r\n};\n\n/*\r\n * Copyright 2018 The boardgame.io Authors\r\n *\r\n * Use of this source code is governed by a MIT-style\r\n * license that can be found in the LICENSE file or at\r\n * https://opensource.org/licenses/MIT.\r\n */\r\n/**\r\n * Plugin that makes it possible to add metadata to log entries.\r\n * During a move, you can set metadata using ctx.log.setMetadata and it will be\r\n * available on the log entry for that move.\r\n */\r\nconst LogPlugin = {\r\n    name: 'log',\r\n    flush: () => ({}),\r\n    api: ({ data }) => {\r\n        return {\r\n            setMetadata: (metadata) => {\r\n                data.metadata = metadata;\r\n            },\r\n        };\r\n    },\r\n    setup: () => ({}),\r\n};\n\n/**\r\n * Check if a value can be serialized (e.g. using `JSON.stringify`).\r\n * Adapted from: https://stackoverflow.com/a/30712764/3829557\r\n */\r\nfunction isSerializable(value) {\r\n    // Primitives are OK.\r\n    if (value === undefined ||\r\n        value === null ||\r\n        typeof value === 'boolean' ||\r\n        typeof value === 'number' ||\r\n        typeof value === 'string') {\r\n        return true;\r\n    }\r\n    // A non-primitive value that is neither a POJO or an array cannot be serialized.\r\n    if (!isPlainObject(value) && !Array.isArray(value)) {\r\n        return false;\r\n    }\r\n    // Recurse entries if the value is an object or array.\r\n    for (const key in value) {\r\n        if (!isSerializable(value[key]))\r\n            return false;\r\n    }\r\n    return true;\r\n}\r\n/**\r\n * Plugin that checks whether state is serializable, in order to avoid\r\n * network serialization bugs.\r\n */\r\nconst SerializablePlugin = {\r\n    name: 'plugin-serializable',\r\n    fnWrap: (move) => (G, ctx, ...args) => {\r\n        const result = move(G, ctx, ...args);\r\n        // Check state in non-production environments.\r\n        if (process.env.NODE_ENV !== 'production' && !isSerializable(result)) {\r\n            throw new Error('Move state is not JSON-serialiazable.\\n' +\r\n                'See https://boardgame.io/documentation/#/?id=state for more information.');\r\n        }\r\n        return result;\r\n    },\r\n};\n\n/*\r\n * Copyright 2018 The boardgame.io Authors\r\n *\r\n * Use of this source code is governed by a MIT-style\r\n * license that can be found in the LICENSE file or at\r\n * https://opensource.org/licenses/MIT.\r\n */\r\n/**\r\n * List of plugins that are always added.\r\n */\r\nconst CORE_PLUGINS = [ImmerPlugin, RandomPlugin, LogPlugin, SerializablePlugin];\r\nconst DEFAULT_PLUGINS = [...CORE_PLUGINS, EventsPlugin];\r\n/**\r\n * Allow plugins to intercept actions and process them.\r\n */\r\nconst ProcessAction = (state, action, opts) => {\r\n    // TODO(#723): Extend error handling to plugins.\r\n    opts.game.plugins\r\n        .filter((plugin) => plugin.action !== undefined)\r\n        .filter((plugin) => plugin.name === action.payload.type)\r\n        .forEach((plugin) => {\r\n        const name = plugin.name;\r\n        const pluginState = state.plugins[name] || { data: {} };\r\n        const data = plugin.action(pluginState.data, action.payload);\r\n        state = {\r\n            ...state,\r\n            plugins: {\r\n                ...state.plugins,\r\n                [name]: { ...pluginState, data },\r\n            },\r\n        };\r\n    });\r\n    return state;\r\n};\r\n/**\r\n * The API's created by various plugins are stored in the plugins\r\n * section of the state object:\r\n *\r\n * {\r\n *   G: {},\r\n *   ctx: {},\r\n *   plugins: {\r\n *     plugin-a: {\r\n *       data: {},  // this is generated by the plugin at Setup / Flush.\r\n *       api: {},   // this is ephemeral and generated by Enhance.\r\n *     }\r\n *   }\r\n * }\r\n *\r\n * This function takes these API's and stuffs them back into\r\n * ctx for consumption inside a move function or hook.\r\n */\r\nconst EnhanceCtx = (state) => {\r\n    const ctx = { ...state.ctx };\r\n    const plugins = state.plugins || {};\r\n    Object.entries(plugins).forEach(([name, { api }]) => {\r\n        ctx[name] = api;\r\n    });\r\n    return ctx;\r\n};\r\n/**\r\n * Applies the provided plugins to the given move / flow function.\r\n *\r\n * @param {function} fn - The move function or trigger to apply the plugins to.\r\n * @param {object} plugins - The list of plugins.\r\n */\r\nconst FnWrap = (fn, plugins) => {\r\n    const reducer = (acc, { fnWrap }) => fnWrap(acc);\r\n    return [...DEFAULT_PLUGINS, ...plugins]\r\n        .filter((plugin) => plugin.fnWrap !== undefined)\r\n        .reduce(reducer, fn);\r\n};\r\n/**\r\n * Allows the plugin to generate its initial state.\r\n */\r\nconst Setup = (state, opts) => {\r\n    [...DEFAULT_PLUGINS, ...opts.game.plugins]\r\n        .filter((plugin) => plugin.setup !== undefined)\r\n        .forEach((plugin) => {\r\n        const name = plugin.name;\r\n        const data = plugin.setup({\r\n            G: state.G,\r\n            ctx: state.ctx,\r\n            game: opts.game,\r\n        });\r\n        state = {\r\n            ...state,\r\n            plugins: {\r\n                ...state.plugins,\r\n                [name]: { data },\r\n            },\r\n        };\r\n    });\r\n    return state;\r\n};\r\n/**\r\n * Invokes the plugin before a move or event.\r\n * The API that the plugin generates is stored inside\r\n * the `plugins` section of the state (which is subsequently\r\n * merged into ctx).\r\n */\r\nconst Enhance = (state, opts) => {\r\n    [...DEFAULT_PLUGINS, ...opts.game.plugins]\r\n        .filter((plugin) => plugin.api !== undefined)\r\n        .forEach((plugin) => {\r\n        const name = plugin.name;\r\n        const pluginState = state.plugins[name] || { data: {} };\r\n        const api = plugin.api({\r\n            G: state.G,\r\n            ctx: state.ctx,\r\n            data: pluginState.data,\r\n            game: opts.game,\r\n            playerID: opts.playerID,\r\n        });\r\n        state = {\r\n            ...state,\r\n            plugins: {\r\n                ...state.plugins,\r\n                [name]: { ...pluginState, api },\r\n            },\r\n        };\r\n    });\r\n    return state;\r\n};\r\n/**\r\n * Allows plugins to update their state after a move / event.\r\n */\r\nconst Flush = (state, opts) => {\r\n    // We flush the events plugin first, then custom plugins and the core plugins.\r\n    // This means custom plugins cannot use the events API but will be available in event hooks.\r\n    // Note that plugins are flushed in reverse, to allow custom plugins calling each other.\r\n    [...CORE_PLUGINS, ...opts.game.plugins, EventsPlugin]\r\n        .reverse()\r\n        .forEach((plugin) => {\r\n        const name = plugin.name;\r\n        const pluginState = state.plugins[name] || { data: {} };\r\n        if (plugin.flush) {\r\n            const newData = plugin.flush({\r\n                G: state.G,\r\n                ctx: state.ctx,\r\n                game: opts.game,\r\n                api: pluginState.api,\r\n                data: pluginState.data,\r\n            });\r\n            state = {\r\n                ...state,\r\n                plugins: {\r\n                    ...state.plugins,\r\n                    [plugin.name]: { data: newData },\r\n                },\r\n            };\r\n        }\r\n        else if (plugin.dangerouslyFlushRawState) {\r\n            state = plugin.dangerouslyFlushRawState({\r\n                state,\r\n                game: opts.game,\r\n                api: pluginState.api,\r\n                data: pluginState.data,\r\n            });\r\n            // Remove everything other than data.\r\n            const data = state.plugins[name].data;\r\n            state = {\r\n                ...state,\r\n                plugins: {\r\n                    ...state.plugins,\r\n                    [plugin.name]: { data },\r\n                },\r\n            };\r\n        }\r\n    });\r\n    return state;\r\n};\r\n/**\r\n * Allows plugins to indicate if they should not be materialized on the client.\r\n * This will cause the client to discard the state update and wait for the\r\n * master instead.\r\n */\r\nconst NoClient = (state, opts) => {\r\n    return [...DEFAULT_PLUGINS, ...opts.game.plugins]\r\n        .filter((plugin) => plugin.noClient !== undefined)\r\n        .map((plugin) => {\r\n        const name = plugin.name;\r\n        const pluginState = state.plugins[name];\r\n        if (pluginState) {\r\n            return plugin.noClient({\r\n                G: state.G,\r\n                ctx: state.ctx,\r\n                game: opts.game,\r\n                api: pluginState.api,\r\n                data: pluginState.data,\r\n            });\r\n        }\r\n        return false;\r\n    })\r\n        .some((value) => value === true);\r\n};\r\n/**\r\n * Allows plugins to customize their data for specific players.\r\n * For example, a plugin may want to share no data with the client, or\r\n * want to keep some player data secret from opponents.\r\n */\r\nconst PlayerView = ({ G, ctx, plugins = {} }, { game, playerID }) => {\r\n    [...DEFAULT_PLUGINS, ...game.plugins].forEach(({ name, playerView }) => {\r\n        if (!playerView)\r\n            return;\r\n        const { data } = plugins[name] || { data: {} };\r\n        const newData = playerView({ G, ctx, game, data, playerID });\r\n        plugins = {\r\n            ...plugins,\r\n            [name]: { data: newData },\r\n        };\r\n    });\r\n    return plugins;\r\n};\n\n/*\r\n * Copyright 2018 The boardgame.io Authors\r\n *\r\n * Use of this source code is governed by a MIT-style\r\n * license that can be found in the LICENSE file or at\r\n * https://opensource.org/licenses/MIT.\r\n */\r\nconst production = process.env.NODE_ENV === 'production';\r\nconst logfn = production ? () => { } : (...msg) => console.log(...msg);\r\nconst errorfn = (...msg) => console.error(...msg);\r\nfunction info(msg) {\r\n    logfn(`INFO: ${msg}`);\r\n}\r\nfunction error(error) {\r\n    errorfn('ERROR:', error);\r\n}\n\n/*\r\n * Copyright 2017 The boardgame.io Authors\r\n *\r\n * Use of this source code is governed by a MIT-style\r\n * license that can be found in the LICENSE file or at\r\n * https://opensource.org/licenses/MIT.\r\n */\r\n/**\r\n * Event to change the active players (and their stages) in the current turn.\r\n */\r\nfunction SetActivePlayersEvent(state, _playerID, arg) {\r\n    return { ...state, ctx: SetActivePlayers(state.ctx, arg) };\r\n}\r\nfunction SetActivePlayers(ctx, arg) {\r\n    let { _prevActivePlayers } = ctx;\r\n    let activePlayers = {};\r\n    let _nextActivePlayers = null;\r\n    let _activePlayersMoveLimit = {};\r\n    if (Array.isArray(arg)) {\r\n        // support a simple array of player IDs as active players\r\n        const value = {};\r\n        arg.forEach((v) => (value[v] = Stage.NULL));\r\n        activePlayers = value;\r\n    }\r\n    else {\r\n        // process active players argument object\r\n        if (arg.next) {\r\n            _nextActivePlayers = arg.next;\r\n        }\r\n        _prevActivePlayers = arg.revert\r\n            ? _prevActivePlayers.concat({\r\n                activePlayers: ctx.activePlayers,\r\n                _activePlayersMoveLimit: ctx._activePlayersMoveLimit,\r\n                _activePlayersNumMoves: ctx._activePlayersNumMoves,\r\n            })\r\n            : [];\r\n        if (arg.currentPlayer !== undefined) {\r\n            ApplyActivePlayerArgument(activePlayers, _activePlayersMoveLimit, ctx.currentPlayer, arg.currentPlayer);\r\n        }\r\n        if (arg.others !== undefined) {\r\n            for (let i = 0; i < ctx.playOrder.length; i++) {\r\n                const id = ctx.playOrder[i];\r\n                if (id !== ctx.currentPlayer) {\r\n                    ApplyActivePlayerArgument(activePlayers, _activePlayersMoveLimit, id, arg.others);\r\n                }\r\n            }\r\n        }\r\n        if (arg.all !== undefined) {\r\n            for (let i = 0; i < ctx.playOrder.length; i++) {\r\n                const id = ctx.playOrder[i];\r\n                ApplyActivePlayerArgument(activePlayers, _activePlayersMoveLimit, id, arg.all);\r\n            }\r\n        }\r\n        if (arg.value) {\r\n            for (const id in arg.value) {\r\n                ApplyActivePlayerArgument(activePlayers, _activePlayersMoveLimit, id, arg.value[id]);\r\n            }\r\n        }\r\n        if (arg.moveLimit) {\r\n            for (const id in activePlayers) {\r\n                if (_activePlayersMoveLimit[id] === undefined) {\r\n                    _activePlayersMoveLimit[id] = arg.moveLimit;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    if (Object.keys(activePlayers).length == 0) {\r\n        activePlayers = null;\r\n    }\r\n    if (Object.keys(_activePlayersMoveLimit).length == 0) {\r\n        _activePlayersMoveLimit = null;\r\n    }\r\n    const _activePlayersNumMoves = {};\r\n    for (const id in activePlayers) {\r\n        _activePlayersNumMoves[id] = 0;\r\n    }\r\n    return {\r\n        ...ctx,\r\n        activePlayers,\r\n        _activePlayersMoveLimit,\r\n        _activePlayersNumMoves,\r\n        _prevActivePlayers,\r\n        _nextActivePlayers,\r\n    };\r\n}\r\n/**\r\n * Update activePlayers, setting it to previous, next or null values\r\n * when it becomes empty.\r\n * @param ctx\r\n */\r\nfunction UpdateActivePlayersOnceEmpty(ctx) {\r\n    let { activePlayers, _activePlayersMoveLimit, _activePlayersNumMoves, _prevActivePlayers, } = ctx;\r\n    if (activePlayers && Object.keys(activePlayers).length == 0) {\r\n        if (ctx._nextActivePlayers) {\r\n            ctx = SetActivePlayers(ctx, ctx._nextActivePlayers);\r\n            ({\r\n                activePlayers,\r\n                _activePlayersMoveLimit,\r\n                _activePlayersNumMoves,\r\n                _prevActivePlayers,\r\n            } = ctx);\r\n        }\r\n        else if (_prevActivePlayers.length > 0) {\r\n            const lastIndex = _prevActivePlayers.length - 1;\r\n            ({\r\n                activePlayers,\r\n                _activePlayersMoveLimit,\r\n                _activePlayersNumMoves,\r\n            } = _prevActivePlayers[lastIndex]);\r\n            _prevActivePlayers = _prevActivePlayers.slice(0, lastIndex);\r\n        }\r\n        else {\r\n            activePlayers = null;\r\n            _activePlayersMoveLimit = null;\r\n        }\r\n    }\r\n    return {\r\n        ...ctx,\r\n        activePlayers,\r\n        _activePlayersMoveLimit,\r\n        _activePlayersNumMoves,\r\n        _prevActivePlayers,\r\n    };\r\n}\r\n/**\r\n * Apply an active player argument to the given player ID\r\n * @param {Object} activePlayers\r\n * @param {Object} _activePlayersMoveLimit\r\n * @param {String} playerID The player to apply the parameter to\r\n * @param {(String|Object)} arg An active player argument\r\n */\r\nfunction ApplyActivePlayerArgument(activePlayers, _activePlayersMoveLimit, playerID, arg) {\r\n    if (typeof arg !== 'object' || arg === Stage.NULL) {\r\n        arg = { stage: arg };\r\n    }\r\n    if (arg.stage !== undefined) {\r\n        activePlayers[playerID] = arg.stage;\r\n        if (arg.moveLimit)\r\n            _activePlayersMoveLimit[playerID] = arg.moveLimit;\r\n    }\r\n}\r\n/**\r\n * Converts a playOrderPos index into its value in playOrder.\r\n * @param {Array} playOrder - An array of player ID's.\r\n * @param {number} playOrderPos - An index into the above.\r\n */\r\nfunction getCurrentPlayer(playOrder, playOrderPos) {\r\n    // convert to string in case playOrder is set to number[]\r\n    return playOrder[playOrderPos] + '';\r\n}\r\n/**\r\n * Called at the start of a turn to initialize turn order state.\r\n *\r\n * TODO: This is called inside StartTurn, which is called from\r\n * both UpdateTurn and StartPhase (so it's called at the beginning\r\n * of a new phase as well as between turns). We should probably\r\n * split it into two.\r\n */\r\nfunction InitTurnOrderState(state, turn) {\r\n    let { G, ctx } = state;\r\n    const ctxWithAPI = EnhanceCtx(state);\r\n    const order = turn.order;\r\n    let playOrder = [...new Array(ctx.numPlayers)].map((_, i) => i + '');\r\n    if (order.playOrder !== undefined) {\r\n        playOrder = order.playOrder(G, ctxWithAPI);\r\n    }\r\n    const playOrderPos = order.first(G, ctxWithAPI);\r\n    const posType = typeof playOrderPos;\r\n    if (posType !== 'number') {\r\n        error(`invalid value returned by turn.order.first — expected number got ${posType} “${playOrderPos}”.`);\r\n    }\r\n    const currentPlayer = getCurrentPlayer(playOrder, playOrderPos);\r\n    ctx = { ...ctx, currentPlayer, playOrderPos, playOrder };\r\n    ctx = SetActivePlayers(ctx, turn.activePlayers || {});\r\n    return ctx;\r\n}\r\n/**\r\n * Called at the end of each turn to update the turn order state.\r\n * @param {object} G - The game object G.\r\n * @param {object} ctx - The game object ctx.\r\n * @param {object} turn - A turn object for this phase.\r\n * @param {string} endTurnArg - An optional argument to endTurn that\r\n                                may specify the next player.\r\n */\r\nfunction UpdateTurnOrderState(state, currentPlayer, turn, endTurnArg) {\r\n    const order = turn.order;\r\n    let { G, ctx } = state;\r\n    let playOrderPos = ctx.playOrderPos;\r\n    let endPhase = false;\r\n    if (endTurnArg && endTurnArg !== true) {\r\n        if (typeof endTurnArg !== 'object') {\r\n            error(`invalid argument to endTurn: ${endTurnArg}`);\r\n        }\r\n        Object.keys(endTurnArg).forEach((arg) => {\r\n            switch (arg) {\r\n                case 'remove':\r\n                    currentPlayer = getCurrentPlayer(ctx.playOrder, playOrderPos);\r\n                    break;\r\n                case 'next':\r\n                    playOrderPos = ctx.playOrder.indexOf(endTurnArg.next);\r\n                    currentPlayer = endTurnArg.next;\r\n                    break;\r\n                default:\r\n                    error(`invalid argument to endTurn: ${arg}`);\r\n            }\r\n        });\r\n    }\r\n    else {\r\n        const ctxWithAPI = EnhanceCtx(state);\r\n        const t = order.next(G, ctxWithAPI);\r\n        const type = typeof t;\r\n        if (t !== undefined && type !== 'number') {\r\n            error(`invalid value returned by turn.order.next — expected number or undefined got ${type} “${t}”.`);\r\n        }\r\n        if (t === undefined) {\r\n            endPhase = true;\r\n        }\r\n        else {\r\n            playOrderPos = t;\r\n            currentPlayer = getCurrentPlayer(ctx.playOrder, playOrderPos);\r\n        }\r\n    }\r\n    ctx = {\r\n        ...ctx,\r\n        playOrderPos,\r\n        currentPlayer,\r\n    };\r\n    return { endPhase, ctx };\r\n}\r\n/**\r\n * Set of different turn orders possible in a phase.\r\n * These are meant to be passed to the `turn` setting\r\n * in the flow objects.\r\n *\r\n * Each object defines the first player when the phase / game\r\n * begins, and also a function `next` to determine who the\r\n * next player is when the turn ends.\r\n *\r\n * The phase ends if next() returns undefined.\r\n */\r\nconst TurnOrder = {\r\n    /**\r\n     * DEFAULT\r\n     *\r\n     * The default round-robin turn order.\r\n     */\r\n    DEFAULT: {\r\n        first: (G, ctx) => ctx.turn === 0\r\n            ? ctx.playOrderPos\r\n            : (ctx.playOrderPos + 1) % ctx.playOrder.length,\r\n        next: (G, ctx) => (ctx.playOrderPos + 1) % ctx.playOrder.length,\r\n    },\r\n    /**\r\n     * RESET\r\n     *\r\n     * Similar to DEFAULT, but starts from 0 each time.\r\n     */\r\n    RESET: {\r\n        first: () => 0,\r\n        next: (G, ctx) => (ctx.playOrderPos + 1) % ctx.playOrder.length,\r\n    },\r\n    /**\r\n     * CONTINUE\r\n     *\r\n     * Similar to DEFAULT, but starts with the player who ended the last phase.\r\n     */\r\n    CONTINUE: {\r\n        first: (G, ctx) => ctx.playOrderPos,\r\n        next: (G, ctx) => (ctx.playOrderPos + 1) % ctx.playOrder.length,\r\n    },\r\n    /**\r\n     * ONCE\r\n     *\r\n     * Another round-robin turn order, but goes around just once.\r\n     * The phase ends after all players have played.\r\n     */\r\n    ONCE: {\r\n        first: () => 0,\r\n        next: (G, ctx) => {\r\n            if (ctx.playOrderPos < ctx.playOrder.length - 1) {\r\n                return ctx.playOrderPos + 1;\r\n            }\r\n        },\r\n    },\r\n    /**\r\n     * CUSTOM\r\n     *\r\n     * Identical to DEFAULT, but also sets playOrder at the\r\n     * beginning of the phase.\r\n     *\r\n     * @param {Array} playOrder - The play order.\r\n     */\r\n    CUSTOM: (playOrder) => ({\r\n        playOrder: () => playOrder,\r\n        first: () => 0,\r\n        next: (G, ctx) => (ctx.playOrderPos + 1) % ctx.playOrder.length,\r\n    }),\r\n    /**\r\n     * CUSTOM_FROM\r\n     *\r\n     * Identical to DEFAULT, but also sets playOrder at the\r\n     * beginning of the phase to a value specified by a field\r\n     * in G.\r\n     *\r\n     * @param {string} playOrderField - Field in G.\r\n     */\r\n    CUSTOM_FROM: (playOrderField) => ({\r\n        playOrder: (G) => G[playOrderField],\r\n        first: () => 0,\r\n        next: (G, ctx) => (ctx.playOrderPos + 1) % ctx.playOrder.length,\r\n    }),\r\n};\r\nconst Stage = {\r\n    NULL: null,\r\n};\r\nconst ActivePlayers = {\r\n    /**\r\n     * ALL\r\n     *\r\n     * The turn stays with one player, but any player can play (in any order)\r\n     * until the phase ends.\r\n     */\r\n    ALL: { all: Stage.NULL },\r\n    /**\r\n     * ALL_ONCE\r\n     *\r\n     * The turn stays with one player, but any player can play (once, and in any order).\r\n     * This is typically used in a phase where you want to elicit a response\r\n     * from every player in the game.\r\n     */\r\n    ALL_ONCE: { all: Stage.NULL, moveLimit: 1 },\r\n    /**\r\n     * OTHERS\r\n     *\r\n     * The turn stays with one player, and every *other* player can play (in any order)\r\n     * until the phase ends.\r\n     */\r\n    OTHERS: { others: Stage.NULL },\r\n    /**\r\n     * OTHERS_ONCE\r\n     *\r\n     * The turn stays with one player, and every *other* player can play (once, and in any order).\r\n     * This is typically used in a phase where you want to elicit a response\r\n     * from every *other* player in the game.\r\n     */\r\n    OTHERS_ONCE: { others: Stage.NULL, moveLimit: 1 },\r\n};\n\nexport { ActionCreators as A, update as B, patch as C, EnhanceCtx as E, FnWrap as F, GAME_EVENT as G, InitTurnOrderState as I, MAKE_MOVE as M, NoClient as N, PLUGIN as P, RESET as R, Stage as S, TurnOrder as T, UpdateTurnOrderState as U, SetActivePlayersEvent as a, SetActivePlayers as b, UpdateActivePlayersOnceEmpty as c, STRIP_TRANSIENTS as d, error as e, Enhance as f, gameEvent as g, Flush as h, info as i, INVALID_MOVE as j, UPDATE as k, SYNC as l, UNDO as m, REDO as n, ProcessAction as o, PATCH as p, stripTransients as q, Setup as r, sync as s, reset as t, undo as u, redo as v, PlayerView as w, makeMove as x, alea as y, ActivePlayers as z };\n"]},"metadata":{},"sourceType":"module"}
{"ast":null,"code":"import { e as error, E as EnhanceCtx, T as TurnOrder, i as info, S as Stage, a as SetActivePlayersEvent, F as FnWrap, b as SetActivePlayers, I as InitTurnOrderState, U as UpdateTurnOrderState, g as gameEvent, c as UpdateActivePlayersOnceEmpty, d as STRIP_TRANSIENTS, G as GAME_EVENT, f as Enhance, h as Flush, M as MAKE_MOVE, j as INVALID_MOVE, N as NoClient, R as RESET, k as UPDATE, l as SYNC, m as UNDO, n as REDO, P as PLUGIN, o as ProcessAction, p as PATCH, q as stripTransients } from './turn-order-62966a9c.js';\nimport { applyPatch } from 'rfc6902';\n/*\r\n * Copyright 2017 The boardgame.io Authors\r\n *\r\n * Use of this source code is governed by a MIT-style\r\n * license that can be found in the LICENSE file or at\r\n * https://opensource.org/licenses/MIT.\r\n */\n\n/**\r\n * Flow\r\n *\r\n * Creates a reducer that updates ctx (analogous to how moves update G).\r\n */\n\nfunction Flow({\n  moves,\n  phases,\n  endIf,\n  onEnd,\n  turn,\n  events,\n  plugins\n}) {\n  // Attach defaults.\n  if (moves === undefined) {\n    moves = {};\n  }\n\n  if (events === undefined) {\n    events = {};\n  }\n\n  if (plugins === undefined) {\n    plugins = [];\n  }\n\n  if (phases === undefined) {\n    phases = {};\n  }\n\n  if (!endIf) endIf = () => undefined;\n  if (!onEnd) onEnd = G => G;\n  if (!turn) turn = {};\n  const phaseMap = { ...phases\n  };\n\n  if ('' in phaseMap) {\n    error('cannot specify phase with empty name');\n  }\n\n  phaseMap[''] = {};\n  const moveMap = {};\n  const moveNames = new Set();\n  let startingPhase = null;\n  Object.keys(moves).forEach(name => moveNames.add(name));\n\n  const HookWrapper = fn => {\n    const withPlugins = FnWrap(fn, plugins);\n    return state => {\n      const ctxWithAPI = EnhanceCtx(state);\n      return withPlugins(state.G, ctxWithAPI);\n    };\n  };\n\n  const TriggerWrapper = endIf => {\n    return state => {\n      const ctxWithAPI = EnhanceCtx(state);\n      return endIf(state.G, ctxWithAPI);\n    };\n  };\n\n  const wrapped = {\n    onEnd: HookWrapper(onEnd),\n    endIf: TriggerWrapper(endIf)\n  };\n\n  for (const phase in phaseMap) {\n    const conf = phaseMap[phase];\n\n    if (conf.start === true) {\n      startingPhase = phase;\n    }\n\n    if (conf.moves !== undefined) {\n      for (const move of Object.keys(conf.moves)) {\n        moveMap[phase + '.' + move] = conf.moves[move];\n        moveNames.add(move);\n      }\n    }\n\n    if (conf.endIf === undefined) {\n      conf.endIf = () => undefined;\n    }\n\n    if (conf.onBegin === undefined) {\n      conf.onBegin = G => G;\n    }\n\n    if (conf.onEnd === undefined) {\n      conf.onEnd = G => G;\n    }\n\n    if (conf.turn === undefined) {\n      conf.turn = turn;\n    }\n\n    if (conf.turn.order === undefined) {\n      conf.turn.order = TurnOrder.DEFAULT;\n    }\n\n    if (conf.turn.onBegin === undefined) {\n      conf.turn.onBegin = G => G;\n    }\n\n    if (conf.turn.onEnd === undefined) {\n      conf.turn.onEnd = G => G;\n    }\n\n    if (conf.turn.endIf === undefined) {\n      conf.turn.endIf = () => false;\n    }\n\n    if (conf.turn.onMove === undefined) {\n      conf.turn.onMove = G => G;\n    }\n\n    if (conf.turn.stages === undefined) {\n      conf.turn.stages = {};\n    }\n\n    for (const stage in conf.turn.stages) {\n      const stageConfig = conf.turn.stages[stage];\n      const moves = stageConfig.moves || {};\n\n      for (const move of Object.keys(moves)) {\n        const key = phase + '.' + stage + '.' + move;\n        moveMap[key] = moves[move];\n        moveNames.add(move);\n      }\n    }\n\n    conf.wrapped = {\n      onBegin: HookWrapper(conf.onBegin),\n      onEnd: HookWrapper(conf.onEnd),\n      endIf: TriggerWrapper(conf.endIf)\n    };\n    conf.turn.wrapped = {\n      onMove: HookWrapper(conf.turn.onMove),\n      onBegin: HookWrapper(conf.turn.onBegin),\n      onEnd: HookWrapper(conf.turn.onEnd),\n      endIf: TriggerWrapper(conf.turn.endIf)\n    };\n  }\n\n  function GetPhase(ctx) {\n    return ctx.phase ? phaseMap[ctx.phase] : phaseMap[''];\n  }\n\n  function OnMove(s) {\n    return s;\n  }\n\n  function Process(state, events) {\n    const phasesEnded = new Set();\n    const turnsEnded = new Set();\n\n    for (let i = 0; i < events.length; i++) {\n      const {\n        fn,\n        arg,\n        ...rest\n      } = events[i]; // Detect a loop of EndPhase calls.\n      // This could potentially even be an infinite loop\n      // if the endIf condition of each phase blindly\n      // returns true. The moment we detect a single\n      // loop, we just bail out of all phases.\n\n      if (fn === EndPhase) {\n        turnsEnded.clear();\n        const phase = state.ctx.phase;\n\n        if (phasesEnded.has(phase)) {\n          const ctx = { ...state.ctx,\n            phase: null\n          };\n          return { ...state,\n            ctx\n          };\n        }\n\n        phasesEnded.add(phase);\n      } // Process event.\n\n\n      const next = [];\n      state = fn(state, { ...rest,\n        arg,\n        next\n      });\n\n      if (fn === EndGame) {\n        break;\n      } // Check if we should end the game.\n\n\n      const shouldEndGame = ShouldEndGame(state);\n\n      if (shouldEndGame) {\n        events.push({\n          fn: EndGame,\n          arg: shouldEndGame,\n          turn: state.ctx.turn,\n          phase: state.ctx.phase,\n          automatic: true\n        });\n        continue;\n      } // Check if we should end the phase.\n\n\n      const shouldEndPhase = ShouldEndPhase(state);\n\n      if (shouldEndPhase) {\n        events.push({\n          fn: EndPhase,\n          arg: shouldEndPhase,\n          turn: state.ctx.turn,\n          phase: state.ctx.phase,\n          automatic: true\n        });\n        continue;\n      } // Check if we should end the turn.\n\n\n      if (fn === OnMove) {\n        const shouldEndTurn = ShouldEndTurn(state);\n\n        if (shouldEndTurn) {\n          events.push({\n            fn: EndTurn,\n            arg: shouldEndTurn,\n            turn: state.ctx.turn,\n            phase: state.ctx.phase,\n            automatic: true\n          });\n          continue;\n        }\n      }\n\n      events.push(...next);\n    }\n\n    return state;\n  } ///////////\n  // Start //\n  ///////////\n\n\n  function StartGame(state, {\n    next\n  }) {\n    next.push({\n      fn: StartPhase\n    });\n    return state;\n  }\n\n  function StartPhase(state, {\n    next\n  }) {\n    let {\n      G,\n      ctx\n    } = state;\n    const conf = GetPhase(ctx); // Run any phase setup code provided by the user.\n\n    G = conf.wrapped.onBegin(state);\n    next.push({\n      fn: StartTurn\n    });\n    return { ...state,\n      G,\n      ctx\n    };\n  }\n\n  function StartTurn(state, {\n    currentPlayer\n  }) {\n    let {\n      G,\n      ctx\n    } = state;\n    const conf = GetPhase(ctx); // Initialize the turn order state.\n\n    if (currentPlayer) {\n      ctx = { ...ctx,\n        currentPlayer\n      };\n\n      if (conf.turn.activePlayers) {\n        ctx = SetActivePlayers(ctx, conf.turn.activePlayers);\n      }\n    } else {\n      // This is only called at the beginning of the phase\n      // when there is no currentPlayer yet.\n      ctx = InitTurnOrderState(state, conf.turn);\n    }\n\n    const turn = ctx.turn + 1;\n    ctx = { ...ctx,\n      turn,\n      numMoves: 0,\n      _prevActivePlayers: []\n    };\n    G = conf.turn.wrapped.onBegin({ ...state,\n      G,\n      ctx\n    });\n    return { ...state,\n      G,\n      ctx,\n      _undo: [],\n      _redo: []\n    };\n  } ////////////\n  // Update //\n  ////////////\n\n\n  function UpdatePhase(state, {\n    arg,\n    next,\n    phase\n  }) {\n    const conf = GetPhase({\n      phase\n    });\n    let {\n      ctx\n    } = state;\n\n    if (arg && arg.next) {\n      if (arg.next in phaseMap) {\n        ctx = { ...ctx,\n          phase: arg.next\n        };\n      } else {\n        error('invalid phase: ' + arg.next);\n        return state;\n      }\n    } else if (conf.next !== undefined) {\n      ctx = { ...ctx,\n        phase: conf.next\n      };\n    } else {\n      ctx = { ...ctx,\n        phase: null\n      };\n    }\n\n    state = { ...state,\n      ctx\n    }; // Start the new phase.\n\n    next.push({\n      fn: StartPhase\n    });\n    return state;\n  }\n\n  function UpdateTurn(state, {\n    arg,\n    currentPlayer,\n    next\n  }) {\n    let {\n      G,\n      ctx\n    } = state;\n    const conf = GetPhase(ctx); // Update turn order state.\n\n    const {\n      endPhase,\n      ctx: newCtx\n    } = UpdateTurnOrderState(state, currentPlayer, conf.turn, arg);\n    ctx = newCtx;\n    state = { ...state,\n      G,\n      ctx\n    };\n\n    if (endPhase) {\n      next.push({\n        fn: EndPhase,\n        turn: ctx.turn,\n        phase: ctx.phase\n      });\n    } else {\n      next.push({\n        fn: StartTurn,\n        currentPlayer: ctx.currentPlayer\n      });\n    }\n\n    return state;\n  }\n\n  function UpdateStage(state, {\n    arg,\n    playerID\n  }) {\n    if (typeof arg === 'string' || arg === Stage.NULL) {\n      arg = {\n        stage: arg\n      };\n    }\n\n    let {\n      ctx\n    } = state;\n    let {\n      activePlayers,\n      _activePlayersMoveLimit,\n      _activePlayersNumMoves\n    } = ctx; // Checking if stage is valid, even Stage.NULL\n\n    if (arg.stage !== undefined) {\n      if (activePlayers === null) {\n        activePlayers = {};\n      }\n\n      activePlayers[playerID] = arg.stage;\n      _activePlayersNumMoves[playerID] = 0;\n\n      if (arg.moveLimit) {\n        if (_activePlayersMoveLimit === null) {\n          _activePlayersMoveLimit = {};\n        }\n\n        _activePlayersMoveLimit[playerID] = arg.moveLimit;\n      }\n    }\n\n    ctx = { ...ctx,\n      activePlayers,\n      _activePlayersMoveLimit,\n      _activePlayersNumMoves\n    };\n    return { ...state,\n      ctx\n    };\n  } ///////////////\n  // ShouldEnd //\n  ///////////////\n\n\n  function ShouldEndGame(state) {\n    return wrapped.endIf(state);\n  }\n\n  function ShouldEndPhase(state) {\n    const conf = GetPhase(state.ctx);\n    return conf.wrapped.endIf(state);\n  }\n\n  function ShouldEndTurn(state) {\n    const conf = GetPhase(state.ctx); // End the turn if the required number of moves has been made.\n\n    const currentPlayerMoves = state.ctx.numMoves || 0;\n\n    if (conf.turn.moveLimit && currentPlayerMoves >= conf.turn.moveLimit) {\n      return true;\n    }\n\n    return conf.turn.wrapped.endIf(state);\n  } /////////\n  // End //\n  /////////\n\n\n  function EndGame(state, {\n    arg,\n    phase\n  }) {\n    state = EndPhase(state, {\n      phase\n    });\n\n    if (arg === undefined) {\n      arg = true;\n    }\n\n    state = { ...state,\n      ctx: { ...state.ctx,\n        gameover: arg\n      }\n    }; // Run game end hook.\n\n    const G = wrapped.onEnd(state);\n    return { ...state,\n      G\n    };\n  }\n\n  function EndPhase(state, {\n    arg,\n    next,\n    turn,\n    automatic\n  }) {\n    // End the turn first.\n    state = EndTurn(state, {\n      turn,\n      force: true,\n      automatic: true\n    });\n    let G = state.G;\n    let ctx = state.ctx;\n\n    if (next) {\n      next.push({\n        fn: UpdatePhase,\n        arg,\n        phase: ctx.phase\n      });\n    } // If we aren't in a phase, there is nothing else to do.\n\n\n    if (ctx.phase === null) {\n      return state;\n    } // Run any cleanup code for the phase that is about to end.\n\n\n    const conf = GetPhase(ctx);\n    G = conf.wrapped.onEnd(state); // Reset the phase.\n\n    ctx = { ...ctx,\n      phase: null\n    }; // Add log entry.\n\n    const action = gameEvent('endPhase', arg);\n    const logEntry = {\n      action,\n      _stateID: state._stateID,\n      turn: state.ctx.turn,\n      phase: state.ctx.phase\n    };\n\n    if (automatic) {\n      logEntry.automatic = true;\n    }\n\n    const deltalog = [...(state.deltalog || []), logEntry];\n    return { ...state,\n      G,\n      ctx,\n      deltalog\n    };\n  }\n\n  function EndTurn(state, {\n    arg,\n    next,\n    turn,\n    force,\n    automatic,\n    playerID\n  }) {\n    // This is not the turn that EndTurn was originally\n    // called for. The turn was probably ended some other way.\n    if (turn !== state.ctx.turn) {\n      return state;\n    }\n\n    let {\n      G,\n      ctx\n    } = state;\n    const conf = GetPhase(ctx); // Prevent ending the turn if moveLimit hasn't been reached.\n\n    const currentPlayerMoves = ctx.numMoves || 0;\n\n    if (!force && conf.turn.moveLimit && currentPlayerMoves < conf.turn.moveLimit) {\n      info(`cannot end turn before making ${conf.turn.moveLimit} moves`);\n      return state;\n    } // Run turn-end triggers.\n\n\n    G = conf.turn.wrapped.onEnd(state);\n\n    if (next) {\n      next.push({\n        fn: UpdateTurn,\n        arg,\n        currentPlayer: ctx.currentPlayer\n      });\n    } // Reset activePlayers.\n\n\n    ctx = { ...ctx,\n      activePlayers: null\n    }; // Remove player from playerOrder\n\n    if (arg && arg.remove) {\n      playerID = playerID || ctx.currentPlayer;\n      const playOrder = ctx.playOrder.filter(i => i != playerID);\n      const playOrderPos = ctx.playOrderPos > playOrder.length - 1 ? 0 : ctx.playOrderPos;\n      ctx = { ...ctx,\n        playOrder,\n        playOrderPos\n      };\n\n      if (playOrder.length === 0) {\n        next.push({\n          fn: EndPhase,\n          turn: ctx.turn,\n          phase: ctx.phase\n        });\n        return state;\n      }\n    } // Add log entry.\n\n\n    const action = gameEvent('endTurn', arg);\n    const logEntry = {\n      action,\n      _stateID: state._stateID,\n      turn: state.ctx.turn,\n      phase: state.ctx.phase\n    };\n\n    if (automatic) {\n      logEntry.automatic = true;\n    }\n\n    const deltalog = [...(state.deltalog || []), logEntry];\n    return { ...state,\n      G,\n      ctx,\n      deltalog,\n      _undo: [],\n      _redo: []\n    };\n  }\n\n  function EndStage(state, {\n    arg,\n    next,\n    automatic,\n    playerID\n  }) {\n    playerID = playerID || state.ctx.currentPlayer;\n    let {\n      ctx\n    } = state;\n    let {\n      activePlayers,\n      _activePlayersMoveLimit\n    } = ctx;\n    const playerInStage = activePlayers !== null && playerID in activePlayers;\n\n    if (!arg && playerInStage) {\n      const conf = GetPhase(ctx);\n      const stage = conf.turn.stages[activePlayers[playerID]];\n      if (stage && stage.next) arg = stage.next;\n    } // Checking if arg is a valid stage, even Stage.NULL\n\n\n    if (next && arg !== undefined) {\n      next.push({\n        fn: UpdateStage,\n        arg,\n        playerID\n      });\n    } // If player isn’t in a stage, there is nothing else to do.\n\n\n    if (!playerInStage) return state; // Remove player from activePlayers.\n\n    activePlayers = Object.keys(activePlayers).filter(id => id !== playerID).reduce((obj, key) => {\n      obj[key] = activePlayers[key];\n      return obj;\n    }, {});\n\n    if (_activePlayersMoveLimit) {\n      // Remove player from _activePlayersMoveLimit.\n      _activePlayersMoveLimit = Object.keys(_activePlayersMoveLimit).filter(id => id !== playerID).reduce((obj, key) => {\n        obj[key] = _activePlayersMoveLimit[key];\n        return obj;\n      }, {});\n    }\n\n    ctx = UpdateActivePlayersOnceEmpty({ ...ctx,\n      activePlayers,\n      _activePlayersMoveLimit\n    }); // Add log entry.\n\n    const action = gameEvent('endStage', arg);\n    const logEntry = {\n      action,\n      _stateID: state._stateID,\n      turn: state.ctx.turn,\n      phase: state.ctx.phase\n    };\n\n    if (automatic) {\n      logEntry.automatic = true;\n    }\n\n    const deltalog = [...(state.deltalog || []), logEntry];\n    return { ...state,\n      ctx,\n      deltalog\n    };\n  }\n  /**\r\n   * Retrieves the relevant move that can be played by playerID.\r\n   *\r\n   * If ctx.activePlayers is set (i.e. one or more players are in some stage),\r\n   * then it attempts to find the move inside the stages config for\r\n   * that turn. If the stage for a player is '', then the player is\r\n   * allowed to make a move (as determined by the phase config), but\r\n   * isn't restricted to a particular set as defined in the stage config.\r\n   *\r\n   * If not, it then looks for the move inside the phase.\r\n   *\r\n   * If it doesn't find the move there, it looks at the global move definition.\r\n   *\r\n   * @param {object} ctx\r\n   * @param {string} name\r\n   * @param {string} playerID\r\n   */\n\n\n  function GetMove(ctx, name, playerID) {\n    const conf = GetPhase(ctx);\n    const stages = conf.turn.stages;\n    const {\n      activePlayers\n    } = ctx;\n\n    if (activePlayers && activePlayers[playerID] !== undefined && activePlayers[playerID] !== Stage.NULL && stages[activePlayers[playerID]] !== undefined && stages[activePlayers[playerID]].moves !== undefined) {\n      // Check if moves are defined for the player's stage.\n      const stage = stages[activePlayers[playerID]];\n      const moves = stage.moves;\n\n      if (name in moves) {\n        return moves[name];\n      }\n    } else if (conf.moves) {\n      // Check if moves are defined for the current phase.\n      if (name in conf.moves) {\n        return conf.moves[name];\n      }\n    } else if (name in moves) {\n      // Check for the move globally.\n      return moves[name];\n    }\n\n    return null;\n  }\n\n  function ProcessMove(state, action) {\n    const conf = GetPhase(state.ctx);\n    const move = GetMove(state.ctx, action.type, action.playerID);\n    const shouldCount = !move || typeof move === 'function' || move.noLimit !== true;\n    const {\n      ctx\n    } = state;\n    const {\n      _activePlayersNumMoves\n    } = ctx;\n    const {\n      playerID\n    } = action;\n    let numMoves = state.ctx.numMoves;\n\n    if (shouldCount) {\n      if (playerID == state.ctx.currentPlayer) {\n        numMoves++;\n      }\n\n      if (ctx.activePlayers) _activePlayersNumMoves[playerID]++;\n    }\n\n    state = { ...state,\n      ctx: { ...ctx,\n        numMoves,\n        _activePlayersNumMoves\n      }\n    };\n\n    if (ctx._activePlayersMoveLimit && _activePlayersNumMoves[playerID] >= ctx._activePlayersMoveLimit[playerID]) {\n      state = EndStage(state, {\n        playerID,\n        automatic: true\n      });\n    }\n\n    const G = conf.turn.wrapped.onMove(state);\n    state = { ...state,\n      G\n    };\n    const events = [{\n      fn: OnMove\n    }];\n    return Process(state, events);\n  }\n\n  function SetStageEvent(state, playerID, arg) {\n    return Process(state, [{\n      fn: EndStage,\n      arg,\n      playerID\n    }]);\n  }\n\n  function EndStageEvent(state, playerID) {\n    return Process(state, [{\n      fn: EndStage,\n      playerID\n    }]);\n  }\n\n  function SetPhaseEvent(state, _playerID, newPhase) {\n    return Process(state, [{\n      fn: EndPhase,\n      phase: state.ctx.phase,\n      turn: state.ctx.turn,\n      arg: {\n        next: newPhase\n      }\n    }]);\n  }\n\n  function EndPhaseEvent(state) {\n    return Process(state, [{\n      fn: EndPhase,\n      phase: state.ctx.phase,\n      turn: state.ctx.turn\n    }]);\n  }\n\n  function EndTurnEvent(state, _playerID, arg) {\n    return Process(state, [{\n      fn: EndTurn,\n      turn: state.ctx.turn,\n      phase: state.ctx.phase,\n      arg\n    }]);\n  }\n\n  function PassEvent(state, _playerID, arg) {\n    return Process(state, [{\n      fn: EndTurn,\n      turn: state.ctx.turn,\n      phase: state.ctx.phase,\n      force: true,\n      arg\n    }]);\n  }\n\n  function EndGameEvent(state, _playerID, arg) {\n    return Process(state, [{\n      fn: EndGame,\n      turn: state.ctx.turn,\n      phase: state.ctx.phase,\n      arg\n    }]);\n  }\n\n  const eventHandlers = {\n    endStage: EndStageEvent,\n    setStage: SetStageEvent,\n    endTurn: EndTurnEvent,\n    pass: PassEvent,\n    endPhase: EndPhaseEvent,\n    setPhase: SetPhaseEvent,\n    endGame: EndGameEvent,\n    setActivePlayers: SetActivePlayersEvent\n  };\n  const enabledEventNames = [];\n\n  if (events.endTurn !== false) {\n    enabledEventNames.push('endTurn');\n  }\n\n  if (events.pass !== false) {\n    enabledEventNames.push('pass');\n  }\n\n  if (events.endPhase !== false) {\n    enabledEventNames.push('endPhase');\n  }\n\n  if (events.setPhase !== false) {\n    enabledEventNames.push('setPhase');\n  }\n\n  if (events.endGame !== false) {\n    enabledEventNames.push('endGame');\n  }\n\n  if (events.setActivePlayers !== false) {\n    enabledEventNames.push('setActivePlayers');\n  }\n\n  if (events.endStage !== false) {\n    enabledEventNames.push('endStage');\n  }\n\n  if (events.setStage !== false) {\n    enabledEventNames.push('setStage');\n  }\n\n  function ProcessEvent(state, action) {\n    const {\n      type,\n      playerID,\n      args\n    } = action.payload;\n\n    if (Object.prototype.hasOwnProperty.call(eventHandlers, type)) {\n      const eventArgs = [state, playerID].concat(args);\n      return eventHandlers[type].apply({}, eventArgs);\n    }\n\n    return state;\n  }\n\n  function IsPlayerActive(_G, ctx, playerID) {\n    if (ctx.activePlayers) {\n      return playerID in ctx.activePlayers;\n    }\n\n    return ctx.currentPlayer === playerID;\n  }\n\n  return {\n    ctx: numPlayers => ({\n      numPlayers,\n      turn: 0,\n      currentPlayer: '0',\n      playOrder: [...new Array(numPlayers)].map((_d, i) => i + ''),\n      playOrderPos: 0,\n      phase: startingPhase,\n      activePlayers: null\n    }),\n    init: state => {\n      return Process(state, [{\n        fn: StartGame\n      }]);\n    },\n    isPlayerActive: IsPlayerActive,\n    eventHandlers,\n    eventNames: Object.keys(eventHandlers),\n    enabledEventNames,\n    moveMap,\n    moveNames: [...moveNames.values()],\n    processMove: ProcessMove,\n    processEvent: ProcessEvent,\n    getMove: GetMove\n  };\n}\n/*\r\n * Copyright 2017 The boardgame.io Authors\r\n *\r\n * Use of this source code is governed by a MIT-style\r\n * license that can be found in the LICENSE file or at\r\n * https://opensource.org/licenses/MIT.\r\n */\n\n\nfunction IsProcessed(game) {\n  return game.processMove !== undefined;\n}\n/**\r\n * Helper to generate the game move reducer. The returned\r\n * reducer has the following signature:\r\n *\r\n * (G, action, ctx) => {}\r\n *\r\n * You can roll your own if you like, or use any Redux\r\n * addon to generate such a reducer.\r\n *\r\n * The convention used in this framework is to\r\n * have action.type contain the name of the move, and\r\n * action.args contain any additional arguments as an\r\n * Array.\r\n */\n\n\nfunction ProcessGameConfig(game) {\n  // The Game() function has already been called on this\n  // config object, so just pass it through.\n  if (IsProcessed(game)) {\n    return game;\n  }\n\n  if (game.name === undefined) game.name = 'default';\n  if (game.deltaState === undefined) game.deltaState = false;\n  if (game.disableUndo === undefined) game.disableUndo = false;\n  if (game.setup === undefined) game.setup = () => ({});\n  if (game.moves === undefined) game.moves = {};\n  if (game.playerView === undefined) game.playerView = G => G;\n  if (game.plugins === undefined) game.plugins = [];\n  game.plugins.forEach(plugin => {\n    if (plugin.name === undefined) {\n      throw new Error('Plugin missing name attribute');\n    }\n\n    if (plugin.name.includes(' ')) {\n      throw new Error(plugin.name + ': Plugin name must not include spaces');\n    }\n  });\n\n  if (game.name.includes(' ')) {\n    throw new Error(game.name + ': Game name must not include spaces');\n  }\n\n  const flow = Flow(game);\n  return { ...game,\n    flow,\n    moveNames: flow.moveNames,\n    pluginNames: game.plugins.map(p => p.name),\n    processMove: (state, action) => {\n      let moveFn = flow.getMove(state.ctx, action.type, action.playerID);\n\n      if (IsLongFormMove(moveFn)) {\n        moveFn = moveFn.move;\n      }\n\n      if (moveFn instanceof Function) {\n        const fn = FnWrap(moveFn, game.plugins);\n        const ctxWithAPI = { ...EnhanceCtx(state),\n          playerID: action.playerID\n        };\n        let args = [];\n\n        if (action.args !== undefined) {\n          args = args.concat(action.args);\n        }\n\n        return fn(state.G, ctxWithAPI, ...args);\n      }\n\n      error(`invalid move object: ${action.type}`);\n      return state.G;\n    }\n  };\n}\n\nfunction IsLongFormMove(move) {\n  return move instanceof Object && move.move !== undefined;\n}\n/*\r\n * Copyright 2017 The boardgame.io Authors\r\n *\r\n * Use of this source code is governed by a MIT-style\r\n * license that can be found in the LICENSE file or at\r\n * https://opensource.org/licenses/MIT.\r\n */\n\n\nvar UpdateErrorType;\n\n(function (UpdateErrorType) {\n  // The action’s credentials were missing or invalid\n  UpdateErrorType[\"UnauthorizedAction\"] = \"update/unauthorized_action\"; // The action’s matchID was not found\n\n  UpdateErrorType[\"MatchNotFound\"] = \"update/match_not_found\"; // Could not apply Patch operation (rfc6902).\n\n  UpdateErrorType[\"PatchFailed\"] = \"update/patch_failed\";\n})(UpdateErrorType || (UpdateErrorType = {}));\n\nvar ActionErrorType;\n\n(function (ActionErrorType) {\n  // The action contained a stale state ID\n  ActionErrorType[\"StaleStateId\"] = \"action/stale_state_id\"; // The requested move is unknown or not currently available\n\n  ActionErrorType[\"UnavailableMove\"] = \"action/unavailable_move\"; // The move declared it was invalid (INVALID_MOVE constant)\n\n  ActionErrorType[\"InvalidMove\"] = \"action/invalid_move\"; // The player making the action is not currently active\n\n  ActionErrorType[\"InactivePlayer\"] = \"action/inactive_player\"; // The game has finished\n\n  ActionErrorType[\"GameOver\"] = \"action/gameover\"; // The requested action is disabled (e.g. undo/redo, events)\n\n  ActionErrorType[\"ActionDisabled\"] = \"action/action_disabled\"; // The requested action is not currently possible\n\n  ActionErrorType[\"ActionInvalid\"] = \"action/action_invalid\";\n})(ActionErrorType || (ActionErrorType = {}));\n/*\r\n * Copyright 2017 The boardgame.io Authors\r\n *\r\n * Use of this source code is governed by a MIT-style\r\n * license that can be found in the LICENSE file or at\r\n * https://opensource.org/licenses/MIT.\r\n */\n\n/**\r\n * Check if the payload for the passed action contains a playerID.\r\n */\n\n\nconst actionHasPlayerID = action => action.payload.playerID !== null && action.payload.playerID !== undefined;\n/**\r\n * Returns true if a move can be undone.\r\n */\n\n\nconst CanUndoMove = (G, ctx, move) => {\n  function HasUndoable(move) {\n    return move.undoable !== undefined;\n  }\n\n  function IsFunction(undoable) {\n    return undoable instanceof Function;\n  }\n\n  if (!HasUndoable(move)) {\n    return true;\n  }\n\n  if (IsFunction(move.undoable)) {\n    return move.undoable(G, ctx);\n  }\n\n  return move.undoable;\n};\n/**\r\n * Update the undo and redo stacks for a move or event.\r\n */\n\n\nfunction updateUndoRedoState(state, opts) {\n  if (opts.game.disableUndo) return state;\n  const undoEntry = {\n    G: state.G,\n    ctx: state.ctx,\n    plugins: state.plugins,\n    playerID: opts.action.payload.playerID || state.ctx.currentPlayer\n  };\n\n  if (opts.action.type === 'MAKE_MOVE') {\n    undoEntry.moveType = opts.action.payload.type;\n  }\n\n  return { ...state,\n    _undo: [...state._undo, undoEntry],\n    // Always reset redo stack when making a move or event\n    _redo: []\n  };\n}\n/**\r\n * Process state, adding the initial deltalog for this action.\r\n */\n\n\nfunction initializeDeltalog(state, action, move) {\n  // Create a log entry for this action.\n  const logEntry = {\n    action,\n    _stateID: state._stateID,\n    turn: state.ctx.turn,\n    phase: state.ctx.phase\n  };\n  const pluginLogMetadata = state.plugins.log.data.metadata;\n\n  if (pluginLogMetadata !== undefined) {\n    logEntry.metadata = pluginLogMetadata;\n  }\n\n  if (typeof move === 'object' && move.redact === true) {\n    logEntry.redact = true;\n  }\n\n  return { ...state,\n    deltalog: [logEntry]\n  };\n}\n/**\r\n * ExtractTransientsFromState\r\n *\r\n * Split out transients from the a TransientState\r\n */\n\n\nfunction ExtractTransients(transientState) {\n  if (!transientState) {\n    // We preserve null for the state for legacy callers, but the transient\n    // field should be undefined if not present to be consistent with the\n    // code path below.\n    return [null, undefined];\n  }\n\n  const {\n    transients,\n    ...state\n  } = transientState;\n  return [state, transients];\n}\n/**\r\n * WithError\r\n *\r\n * Augment a State instance with transient error information.\r\n */\n\n\nfunction WithError(state, errorType, payload) {\n  const error = {\n    type: errorType,\n    payload\n  };\n  return { ...state,\n    transients: {\n      error\n    }\n  };\n}\n/**\r\n * Middleware for processing TransientState associated with the reducer\r\n * returned by CreateGameReducer.\r\n * This should pretty much be used everywhere you want realistic state\r\n * transitions and error handling.\r\n */\n\n\nconst TransientHandlingMiddleware = store => next => action => {\n  const result = next(action);\n\n  switch (action.type) {\n    case STRIP_TRANSIENTS:\n      {\n        return result;\n      }\n\n    default:\n      {\n        const [, transients] = ExtractTransients(store.getState());\n\n        if (typeof transients !== 'undefined') {\n          store.dispatch(stripTransients()); // Dev Note: If parent middleware needs to correlate the spawned\n          // StripTransients action to the triggering action, instrument here.\n          //\n          // This is a bit tricky; for more details, see:\n          //   https://github.com/boardgameio/boardgame.io/pull/940#discussion_r636200648\n\n          return { ...result,\n            transients\n          };\n        }\n\n        return result;\n      }\n  }\n};\n/**\r\n * CreateGameReducer\r\n *\r\n * Creates the main game state reducer.\r\n */\n\n\nfunction CreateGameReducer({\n  game,\n  isClient\n}) {\n  game = ProcessGameConfig(game);\n  /**\r\n   * GameReducer\r\n   *\r\n   * Redux reducer that maintains the overall game state.\r\n   * @param {object} state - The state before the action.\r\n   * @param {object} action - A Redux action.\r\n   */\n\n  return (stateWithTransients = null, action) => {\n    let [state\n    /*, transients */\n    ] = ExtractTransients(stateWithTransients);\n\n    switch (action.type) {\n      case STRIP_TRANSIENTS:\n        {\n          // This action indicates that transient metadata in the state has been\n          // consumed and should now be stripped from the state..\n          return state;\n        }\n\n      case GAME_EVENT:\n        {\n          state = { ...state,\n            deltalog: []\n          }; // Process game events only on the server.\n          // These events like `endTurn` typically\n          // contain code that may rely on secret state\n          // and cannot be computed on the client.\n\n          if (isClient) {\n            return state;\n          } // Disallow events once the game is over.\n\n\n          if (state.ctx.gameover !== undefined) {\n            error(`cannot call event after game end`);\n            return WithError(state, ActionErrorType.GameOver);\n          } // Ignore the event if the player isn't active.\n\n\n          if (actionHasPlayerID(action) && !game.flow.isPlayerActive(state.G, state.ctx, action.payload.playerID)) {\n            error(`disallowed event: ${action.payload.type}`);\n            return WithError(state, ActionErrorType.InactivePlayer);\n          } // Execute plugins.\n\n\n          state = Enhance(state, {\n            game,\n            isClient: false,\n            playerID: action.payload.playerID\n          }); // Process event.\n\n          let newState = game.flow.processEvent(state, action); // Execute plugins.\n\n          newState = Flush(newState, {\n            game,\n            isClient: false\n          }); // Update undo / redo state.\n\n          newState = updateUndoRedoState(newState, {\n            game,\n            action\n          });\n          return { ...newState,\n            _stateID: state._stateID + 1\n          };\n        }\n\n      case MAKE_MOVE:\n        {\n          state = { ...state,\n            deltalog: []\n          }; // Check whether the move is allowed at this time.\n\n          const move = game.flow.getMove(state.ctx, action.payload.type, action.payload.playerID || state.ctx.currentPlayer);\n\n          if (move === null) {\n            error(`disallowed move: ${action.payload.type}`);\n            return WithError(state, ActionErrorType.UnavailableMove);\n          } // Don't run move on client if move says so.\n\n\n          if (isClient && move.client === false) {\n            return state;\n          } // Disallow moves once the game is over.\n\n\n          if (state.ctx.gameover !== undefined) {\n            error(`cannot make move after game end`);\n            return WithError(state, ActionErrorType.GameOver);\n          } // Ignore the move if the player isn't active.\n\n\n          if (actionHasPlayerID(action) && !game.flow.isPlayerActive(state.G, state.ctx, action.payload.playerID)) {\n            error(`disallowed move: ${action.payload.type}`);\n            return WithError(state, ActionErrorType.InactivePlayer);\n          } // Execute plugins.\n\n\n          state = Enhance(state, {\n            game,\n            isClient,\n            playerID: action.payload.playerID\n          }); // Process the move.\n\n          const G = game.processMove(state, action.payload); // The game declared the move as invalid.\n\n          if (G === INVALID_MOVE) {\n            error(`invalid move: ${action.payload.type} args: ${action.payload.args}`); // TODO(#723): Marshal a nice error payload with the processed move.\n\n            return WithError(state, ActionErrorType.InvalidMove);\n          }\n\n          const newState = { ...state,\n            G\n          }; // Some plugin indicated that it is not suitable to be\n          // materialized on the client (and must wait for the server\n          // response instead).\n\n          if (isClient && NoClient(newState, {\n            game\n          })) {\n            return state;\n          }\n\n          state = newState; // If we're on the client, just process the move\n          // and no triggers in multiplayer mode.\n          // These will be processed on the server, which\n          // will send back a state update.\n\n          if (isClient) {\n            state = Flush(state, {\n              game,\n              isClient: true\n            });\n            return { ...state,\n              _stateID: state._stateID + 1\n            };\n          } // On the server, construct the deltalog.\n\n\n          state = initializeDeltalog(state, action, move); // Allow the flow reducer to process any triggers that happen after moves.\n\n          state = game.flow.processMove(state, action.payload);\n          state = Flush(state, {\n            game\n          }); // Update undo / redo state.\n\n          state = updateUndoRedoState(state, {\n            game,\n            action\n          });\n          return { ...state,\n            _stateID: state._stateID + 1\n          };\n        }\n\n      case RESET:\n      case UPDATE:\n      case SYNC:\n        {\n          return action.state;\n        }\n\n      case UNDO:\n        {\n          state = { ...state,\n            deltalog: []\n          };\n\n          if (game.disableUndo) {\n            error('Undo is not enabled');\n            return WithError(state, ActionErrorType.ActionDisabled);\n          }\n\n          const {\n            _undo,\n            _redo\n          } = state;\n\n          if (_undo.length < 2) {\n            error(`No moves to undo`);\n            return WithError(state, ActionErrorType.ActionInvalid);\n          }\n\n          const last = _undo[_undo.length - 1];\n          const restore = _undo[_undo.length - 2]; // Only allow players to undo their own moves.\n\n          if (actionHasPlayerID(action) && action.payload.playerID !== last.playerID) {\n            error(`Cannot undo other players' moves`);\n            return WithError(state, ActionErrorType.ActionInvalid);\n          } // If undoing a move, check it is undoable.\n\n\n          if (last.moveType) {\n            const lastMove = game.flow.getMove(restore.ctx, last.moveType, last.playerID);\n\n            if (!CanUndoMove(state.G, state.ctx, lastMove)) {\n              error(`Move cannot be undone`);\n              return WithError(state, ActionErrorType.ActionInvalid);\n            }\n          }\n\n          state = initializeDeltalog(state, action);\n          return { ...state,\n            G: restore.G,\n            ctx: restore.ctx,\n            plugins: restore.plugins,\n            _stateID: state._stateID + 1,\n            _undo: _undo.slice(0, -1),\n            _redo: [last, ..._redo]\n          };\n        }\n\n      case REDO:\n        {\n          state = { ...state,\n            deltalog: []\n          };\n\n          if (game.disableUndo) {\n            error('Redo is not enabled');\n            return WithError(state, ActionErrorType.ActionDisabled);\n          }\n\n          const {\n            _undo,\n            _redo\n          } = state;\n\n          if (_redo.length == 0) {\n            error(`No moves to redo`);\n            return WithError(state, ActionErrorType.ActionInvalid);\n          }\n\n          const first = _redo[0]; // Only allow players to redo their own undos.\n\n          if (actionHasPlayerID(action) && action.payload.playerID !== first.playerID) {\n            error(`Cannot redo other players' moves`);\n            return WithError(state, ActionErrorType.ActionInvalid);\n          }\n\n          state = initializeDeltalog(state, action);\n          return { ...state,\n            G: first.G,\n            ctx: first.ctx,\n            plugins: first.plugins,\n            _stateID: state._stateID + 1,\n            _undo: [..._undo, first],\n            _redo: _redo.slice(1)\n          };\n        }\n\n      case PLUGIN:\n        {\n          // TODO(#723): Expose error semantics to plugin processing.\n          return ProcessAction(state, action, {\n            game\n          });\n        }\n\n      case PATCH:\n        {\n          const oldState = state;\n          const newState = JSON.parse(JSON.stringify(oldState));\n          const patchError = applyPatch(newState, action.patch);\n          const hasError = patchError.some(entry => entry !== null);\n\n          if (hasError) {\n            error(`Patch ${JSON.stringify(action.patch)} apply failed`);\n            return WithError(oldState, UpdateErrorType.PatchFailed, patchError);\n          } else {\n            return newState;\n          }\n        }\n\n      default:\n        {\n          return state;\n        }\n    }\n  };\n}\n\nexport { CreateGameReducer as C, IsLongFormMove as I, ProcessGameConfig as P, TransientHandlingMiddleware as T };","map":{"version":3,"sources":["/Users/goldenowl/Desktop/example-boardgame/node_modules/boardgame.io/dist/esm/reducer-763b001e.js"],"names":["e","error","E","EnhanceCtx","T","TurnOrder","i","info","S","Stage","a","SetActivePlayersEvent","F","FnWrap","b","SetActivePlayers","I","InitTurnOrderState","U","UpdateTurnOrderState","g","gameEvent","c","UpdateActivePlayersOnceEmpty","d","STRIP_TRANSIENTS","G","GAME_EVENT","f","Enhance","h","Flush","M","MAKE_MOVE","j","INVALID_MOVE","N","NoClient","R","RESET","k","UPDATE","l","SYNC","m","UNDO","n","REDO","P","PLUGIN","o","ProcessAction","p","PATCH","q","stripTransients","applyPatch","Flow","moves","phases","endIf","onEnd","turn","events","plugins","undefined","phaseMap","moveMap","moveNames","Set","startingPhase","Object","keys","forEach","name","add","HookWrapper","fn","withPlugins","state","ctxWithAPI","TriggerWrapper","wrapped","phase","conf","start","move","onBegin","order","DEFAULT","onMove","stages","stage","stageConfig","key","GetPhase","ctx","OnMove","s","Process","phasesEnded","turnsEnded","length","arg","rest","EndPhase","clear","has","next","EndGame","shouldEndGame","ShouldEndGame","push","automatic","shouldEndPhase","ShouldEndPhase","shouldEndTurn","ShouldEndTurn","EndTurn","StartGame","StartPhase","StartTurn","currentPlayer","activePlayers","numMoves","_prevActivePlayers","_undo","_redo","UpdatePhase","UpdateTurn","endPhase","newCtx","UpdateStage","playerID","NULL","_activePlayersMoveLimit","_activePlayersNumMoves","moveLimit","currentPlayerMoves","gameover","force","action","logEntry","_stateID","deltalog","remove","playOrder","filter","playOrderPos","EndStage","playerInStage","id","reduce","obj","GetMove","ProcessMove","type","shouldCount","noLimit","SetStageEvent","EndStageEvent","SetPhaseEvent","_playerID","newPhase","EndPhaseEvent","EndTurnEvent","PassEvent","EndGameEvent","eventHandlers","endStage","setStage","endTurn","pass","setPhase","endGame","setActivePlayers","enabledEventNames","ProcessEvent","args","payload","prototype","hasOwnProperty","call","eventArgs","concat","apply","IsPlayerActive","_G","numPlayers","Array","map","_d","init","isPlayerActive","eventNames","values","processMove","processEvent","getMove","IsProcessed","game","ProcessGameConfig","deltaState","disableUndo","setup","playerView","plugin","Error","includes","flow","pluginNames","moveFn","IsLongFormMove","Function","UpdateErrorType","ActionErrorType","actionHasPlayerID","CanUndoMove","HasUndoable","undoable","IsFunction","updateUndoRedoState","opts","undoEntry","moveType","initializeDeltalog","pluginLogMetadata","log","data","metadata","redact","ExtractTransients","transientState","transients","WithError","errorType","TransientHandlingMiddleware","store","result","getState","dispatch","CreateGameReducer","isClient","stateWithTransients","GameOver","InactivePlayer","newState","UnavailableMove","client","InvalidMove","ActionDisabled","ActionInvalid","last","restore","lastMove","slice","first","oldState","JSON","parse","stringify","patchError","patch","hasError","some","entry","PatchFailed","C"],"mappings":"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","sourcesContent":["import { e as error, E as EnhanceCtx, T as TurnOrder, i as info, S as Stage, a as SetActivePlayersEvent, F as FnWrap, b as SetActivePlayers, I as InitTurnOrderState, U as UpdateTurnOrderState, g as gameEvent, c as UpdateActivePlayersOnceEmpty, d as STRIP_TRANSIENTS, G as GAME_EVENT, f as Enhance, h as Flush, M as MAKE_MOVE, j as INVALID_MOVE, N as NoClient, R as RESET, k as UPDATE, l as SYNC, m as UNDO, n as REDO, P as PLUGIN, o as ProcessAction, p as PATCH, q as stripTransients } from './turn-order-62966a9c.js';\nimport { applyPatch } from 'rfc6902';\n\n/*\r\n * Copyright 2017 The boardgame.io Authors\r\n *\r\n * Use of this source code is governed by a MIT-style\r\n * license that can be found in the LICENSE file or at\r\n * https://opensource.org/licenses/MIT.\r\n */\r\n/**\r\n * Flow\r\n *\r\n * Creates a reducer that updates ctx (analogous to how moves update G).\r\n */\r\nfunction Flow({ moves, phases, endIf, onEnd, turn, events, plugins, }) {\r\n    // Attach defaults.\r\n    if (moves === undefined) {\r\n        moves = {};\r\n    }\r\n    if (events === undefined) {\r\n        events = {};\r\n    }\r\n    if (plugins === undefined) {\r\n        plugins = [];\r\n    }\r\n    if (phases === undefined) {\r\n        phases = {};\r\n    }\r\n    if (!endIf)\r\n        endIf = () => undefined;\r\n    if (!onEnd)\r\n        onEnd = (G) => G;\r\n    if (!turn)\r\n        turn = {};\r\n    const phaseMap = { ...phases };\r\n    if ('' in phaseMap) {\r\n        error('cannot specify phase with empty name');\r\n    }\r\n    phaseMap[''] = {};\r\n    const moveMap = {};\r\n    const moveNames = new Set();\r\n    let startingPhase = null;\r\n    Object.keys(moves).forEach((name) => moveNames.add(name));\r\n    const HookWrapper = (fn) => {\r\n        const withPlugins = FnWrap(fn, plugins);\r\n        return (state) => {\r\n            const ctxWithAPI = EnhanceCtx(state);\r\n            return withPlugins(state.G, ctxWithAPI);\r\n        };\r\n    };\r\n    const TriggerWrapper = (endIf) => {\r\n        return (state) => {\r\n            const ctxWithAPI = EnhanceCtx(state);\r\n            return endIf(state.G, ctxWithAPI);\r\n        };\r\n    };\r\n    const wrapped = {\r\n        onEnd: HookWrapper(onEnd),\r\n        endIf: TriggerWrapper(endIf),\r\n    };\r\n    for (const phase in phaseMap) {\r\n        const conf = phaseMap[phase];\r\n        if (conf.start === true) {\r\n            startingPhase = phase;\r\n        }\r\n        if (conf.moves !== undefined) {\r\n            for (const move of Object.keys(conf.moves)) {\r\n                moveMap[phase + '.' + move] = conf.moves[move];\r\n                moveNames.add(move);\r\n            }\r\n        }\r\n        if (conf.endIf === undefined) {\r\n            conf.endIf = () => undefined;\r\n        }\r\n        if (conf.onBegin === undefined) {\r\n            conf.onBegin = (G) => G;\r\n        }\r\n        if (conf.onEnd === undefined) {\r\n            conf.onEnd = (G) => G;\r\n        }\r\n        if (conf.turn === undefined) {\r\n            conf.turn = turn;\r\n        }\r\n        if (conf.turn.order === undefined) {\r\n            conf.turn.order = TurnOrder.DEFAULT;\r\n        }\r\n        if (conf.turn.onBegin === undefined) {\r\n            conf.turn.onBegin = (G) => G;\r\n        }\r\n        if (conf.turn.onEnd === undefined) {\r\n            conf.turn.onEnd = (G) => G;\r\n        }\r\n        if (conf.turn.endIf === undefined) {\r\n            conf.turn.endIf = () => false;\r\n        }\r\n        if (conf.turn.onMove === undefined) {\r\n            conf.turn.onMove = (G) => G;\r\n        }\r\n        if (conf.turn.stages === undefined) {\r\n            conf.turn.stages = {};\r\n        }\r\n        for (const stage in conf.turn.stages) {\r\n            const stageConfig = conf.turn.stages[stage];\r\n            const moves = stageConfig.moves || {};\r\n            for (const move of Object.keys(moves)) {\r\n                const key = phase + '.' + stage + '.' + move;\r\n                moveMap[key] = moves[move];\r\n                moveNames.add(move);\r\n            }\r\n        }\r\n        conf.wrapped = {\r\n            onBegin: HookWrapper(conf.onBegin),\r\n            onEnd: HookWrapper(conf.onEnd),\r\n            endIf: TriggerWrapper(conf.endIf),\r\n        };\r\n        conf.turn.wrapped = {\r\n            onMove: HookWrapper(conf.turn.onMove),\r\n            onBegin: HookWrapper(conf.turn.onBegin),\r\n            onEnd: HookWrapper(conf.turn.onEnd),\r\n            endIf: TriggerWrapper(conf.turn.endIf),\r\n        };\r\n    }\r\n    function GetPhase(ctx) {\r\n        return ctx.phase ? phaseMap[ctx.phase] : phaseMap[''];\r\n    }\r\n    function OnMove(s) {\r\n        return s;\r\n    }\r\n    function Process(state, events) {\r\n        const phasesEnded = new Set();\r\n        const turnsEnded = new Set();\r\n        for (let i = 0; i < events.length; i++) {\r\n            const { fn, arg, ...rest } = events[i];\r\n            // Detect a loop of EndPhase calls.\r\n            // This could potentially even be an infinite loop\r\n            // if the endIf condition of each phase blindly\r\n            // returns true. The moment we detect a single\r\n            // loop, we just bail out of all phases.\r\n            if (fn === EndPhase) {\r\n                turnsEnded.clear();\r\n                const phase = state.ctx.phase;\r\n                if (phasesEnded.has(phase)) {\r\n                    const ctx = { ...state.ctx, phase: null };\r\n                    return { ...state, ctx };\r\n                }\r\n                phasesEnded.add(phase);\r\n            }\r\n            // Process event.\r\n            const next = [];\r\n            state = fn(state, {\r\n                ...rest,\r\n                arg,\r\n                next,\r\n            });\r\n            if (fn === EndGame) {\r\n                break;\r\n            }\r\n            // Check if we should end the game.\r\n            const shouldEndGame = ShouldEndGame(state);\r\n            if (shouldEndGame) {\r\n                events.push({\r\n                    fn: EndGame,\r\n                    arg: shouldEndGame,\r\n                    turn: state.ctx.turn,\r\n                    phase: state.ctx.phase,\r\n                    automatic: true,\r\n                });\r\n                continue;\r\n            }\r\n            // Check if we should end the phase.\r\n            const shouldEndPhase = ShouldEndPhase(state);\r\n            if (shouldEndPhase) {\r\n                events.push({\r\n                    fn: EndPhase,\r\n                    arg: shouldEndPhase,\r\n                    turn: state.ctx.turn,\r\n                    phase: state.ctx.phase,\r\n                    automatic: true,\r\n                });\r\n                continue;\r\n            }\r\n            // Check if we should end the turn.\r\n            if (fn === OnMove) {\r\n                const shouldEndTurn = ShouldEndTurn(state);\r\n                if (shouldEndTurn) {\r\n                    events.push({\r\n                        fn: EndTurn,\r\n                        arg: shouldEndTurn,\r\n                        turn: state.ctx.turn,\r\n                        phase: state.ctx.phase,\r\n                        automatic: true,\r\n                    });\r\n                    continue;\r\n                }\r\n            }\r\n            events.push(...next);\r\n        }\r\n        return state;\r\n    }\r\n    ///////////\r\n    // Start //\r\n    ///////////\r\n    function StartGame(state, { next }) {\r\n        next.push({ fn: StartPhase });\r\n        return state;\r\n    }\r\n    function StartPhase(state, { next }) {\r\n        let { G, ctx } = state;\r\n        const conf = GetPhase(ctx);\r\n        // Run any phase setup code provided by the user.\r\n        G = conf.wrapped.onBegin(state);\r\n        next.push({ fn: StartTurn });\r\n        return { ...state, G, ctx };\r\n    }\r\n    function StartTurn(state, { currentPlayer }) {\r\n        let { G, ctx } = state;\r\n        const conf = GetPhase(ctx);\r\n        // Initialize the turn order state.\r\n        if (currentPlayer) {\r\n            ctx = { ...ctx, currentPlayer };\r\n            if (conf.turn.activePlayers) {\r\n                ctx = SetActivePlayers(ctx, conf.turn.activePlayers);\r\n            }\r\n        }\r\n        else {\r\n            // This is only called at the beginning of the phase\r\n            // when there is no currentPlayer yet.\r\n            ctx = InitTurnOrderState(state, conf.turn);\r\n        }\r\n        const turn = ctx.turn + 1;\r\n        ctx = { ...ctx, turn, numMoves: 0, _prevActivePlayers: [] };\r\n        G = conf.turn.wrapped.onBegin({ ...state, G, ctx });\r\n        return { ...state, G, ctx, _undo: [], _redo: [] };\r\n    }\r\n    ////////////\r\n    // Update //\r\n    ////////////\r\n    function UpdatePhase(state, { arg, next, phase }) {\r\n        const conf = GetPhase({ phase });\r\n        let { ctx } = state;\r\n        if (arg && arg.next) {\r\n            if (arg.next in phaseMap) {\r\n                ctx = { ...ctx, phase: arg.next };\r\n            }\r\n            else {\r\n                error('invalid phase: ' + arg.next);\r\n                return state;\r\n            }\r\n        }\r\n        else if (conf.next !== undefined) {\r\n            ctx = { ...ctx, phase: conf.next };\r\n        }\r\n        else {\r\n            ctx = { ...ctx, phase: null };\r\n        }\r\n        state = { ...state, ctx };\r\n        // Start the new phase.\r\n        next.push({ fn: StartPhase });\r\n        return state;\r\n    }\r\n    function UpdateTurn(state, { arg, currentPlayer, next }) {\r\n        let { G, ctx } = state;\r\n        const conf = GetPhase(ctx);\r\n        // Update turn order state.\r\n        const { endPhase, ctx: newCtx } = UpdateTurnOrderState(state, currentPlayer, conf.turn, arg);\r\n        ctx = newCtx;\r\n        state = { ...state, G, ctx };\r\n        if (endPhase) {\r\n            next.push({ fn: EndPhase, turn: ctx.turn, phase: ctx.phase });\r\n        }\r\n        else {\r\n            next.push({ fn: StartTurn, currentPlayer: ctx.currentPlayer });\r\n        }\r\n        return state;\r\n    }\r\n    function UpdateStage(state, { arg, playerID }) {\r\n        if (typeof arg === 'string' || arg === Stage.NULL) {\r\n            arg = { stage: arg };\r\n        }\r\n        let { ctx } = state;\r\n        let { activePlayers, _activePlayersMoveLimit, _activePlayersNumMoves, } = ctx;\r\n        // Checking if stage is valid, even Stage.NULL\r\n        if (arg.stage !== undefined) {\r\n            if (activePlayers === null) {\r\n                activePlayers = {};\r\n            }\r\n            activePlayers[playerID] = arg.stage;\r\n            _activePlayersNumMoves[playerID] = 0;\r\n            if (arg.moveLimit) {\r\n                if (_activePlayersMoveLimit === null) {\r\n                    _activePlayersMoveLimit = {};\r\n                }\r\n                _activePlayersMoveLimit[playerID] = arg.moveLimit;\r\n            }\r\n        }\r\n        ctx = {\r\n            ...ctx,\r\n            activePlayers,\r\n            _activePlayersMoveLimit,\r\n            _activePlayersNumMoves,\r\n        };\r\n        return { ...state, ctx };\r\n    }\r\n    ///////////////\r\n    // ShouldEnd //\r\n    ///////////////\r\n    function ShouldEndGame(state) {\r\n        return wrapped.endIf(state);\r\n    }\r\n    function ShouldEndPhase(state) {\r\n        const conf = GetPhase(state.ctx);\r\n        return conf.wrapped.endIf(state);\r\n    }\r\n    function ShouldEndTurn(state) {\r\n        const conf = GetPhase(state.ctx);\r\n        // End the turn if the required number of moves has been made.\r\n        const currentPlayerMoves = state.ctx.numMoves || 0;\r\n        if (conf.turn.moveLimit && currentPlayerMoves >= conf.turn.moveLimit) {\r\n            return true;\r\n        }\r\n        return conf.turn.wrapped.endIf(state);\r\n    }\r\n    /////////\r\n    // End //\r\n    /////////\r\n    function EndGame(state, { arg, phase }) {\r\n        state = EndPhase(state, { phase });\r\n        if (arg === undefined) {\r\n            arg = true;\r\n        }\r\n        state = { ...state, ctx: { ...state.ctx, gameover: arg } };\r\n        // Run game end hook.\r\n        const G = wrapped.onEnd(state);\r\n        return { ...state, G };\r\n    }\r\n    function EndPhase(state, { arg, next, turn, automatic }) {\r\n        // End the turn first.\r\n        state = EndTurn(state, { turn, force: true, automatic: true });\r\n        let G = state.G;\r\n        let ctx = state.ctx;\r\n        if (next) {\r\n            next.push({ fn: UpdatePhase, arg, phase: ctx.phase });\r\n        }\r\n        // If we aren't in a phase, there is nothing else to do.\r\n        if (ctx.phase === null) {\r\n            return state;\r\n        }\r\n        // Run any cleanup code for the phase that is about to end.\r\n        const conf = GetPhase(ctx);\r\n        G = conf.wrapped.onEnd(state);\r\n        // Reset the phase.\r\n        ctx = { ...ctx, phase: null };\r\n        // Add log entry.\r\n        const action = gameEvent('endPhase', arg);\r\n        const logEntry = {\r\n            action,\r\n            _stateID: state._stateID,\r\n            turn: state.ctx.turn,\r\n            phase: state.ctx.phase,\r\n        };\r\n        if (automatic) {\r\n            logEntry.automatic = true;\r\n        }\r\n        const deltalog = [...(state.deltalog || []), logEntry];\r\n        return { ...state, G, ctx, deltalog };\r\n    }\r\n    function EndTurn(state, { arg, next, turn, force, automatic, playerID }) {\r\n        // This is not the turn that EndTurn was originally\r\n        // called for. The turn was probably ended some other way.\r\n        if (turn !== state.ctx.turn) {\r\n            return state;\r\n        }\r\n        let { G, ctx } = state;\r\n        const conf = GetPhase(ctx);\r\n        // Prevent ending the turn if moveLimit hasn't been reached.\r\n        const currentPlayerMoves = ctx.numMoves || 0;\r\n        if (!force &&\r\n            conf.turn.moveLimit &&\r\n            currentPlayerMoves < conf.turn.moveLimit) {\r\n            info(`cannot end turn before making ${conf.turn.moveLimit} moves`);\r\n            return state;\r\n        }\r\n        // Run turn-end triggers.\r\n        G = conf.turn.wrapped.onEnd(state);\r\n        if (next) {\r\n            next.push({ fn: UpdateTurn, arg, currentPlayer: ctx.currentPlayer });\r\n        }\r\n        // Reset activePlayers.\r\n        ctx = { ...ctx, activePlayers: null };\r\n        // Remove player from playerOrder\r\n        if (arg && arg.remove) {\r\n            playerID = playerID || ctx.currentPlayer;\r\n            const playOrder = ctx.playOrder.filter((i) => i != playerID);\r\n            const playOrderPos = ctx.playOrderPos > playOrder.length - 1 ? 0 : ctx.playOrderPos;\r\n            ctx = { ...ctx, playOrder, playOrderPos };\r\n            if (playOrder.length === 0) {\r\n                next.push({ fn: EndPhase, turn: ctx.turn, phase: ctx.phase });\r\n                return state;\r\n            }\r\n        }\r\n        // Add log entry.\r\n        const action = gameEvent('endTurn', arg);\r\n        const logEntry = {\r\n            action,\r\n            _stateID: state._stateID,\r\n            turn: state.ctx.turn,\r\n            phase: state.ctx.phase,\r\n        };\r\n        if (automatic) {\r\n            logEntry.automatic = true;\r\n        }\r\n        const deltalog = [...(state.deltalog || []), logEntry];\r\n        return { ...state, G, ctx, deltalog, _undo: [], _redo: [] };\r\n    }\r\n    function EndStage(state, { arg, next, automatic, playerID }) {\r\n        playerID = playerID || state.ctx.currentPlayer;\r\n        let { ctx } = state;\r\n        let { activePlayers, _activePlayersMoveLimit } = ctx;\r\n        const playerInStage = activePlayers !== null && playerID in activePlayers;\r\n        if (!arg && playerInStage) {\r\n            const conf = GetPhase(ctx);\r\n            const stage = conf.turn.stages[activePlayers[playerID]];\r\n            if (stage && stage.next)\r\n                arg = stage.next;\r\n        }\r\n        // Checking if arg is a valid stage, even Stage.NULL\r\n        if (next && arg !== undefined) {\r\n            next.push({ fn: UpdateStage, arg, playerID });\r\n        }\r\n        // If player isn’t in a stage, there is nothing else to do.\r\n        if (!playerInStage)\r\n            return state;\r\n        // Remove player from activePlayers.\r\n        activePlayers = Object.keys(activePlayers)\r\n            .filter((id) => id !== playerID)\r\n            .reduce((obj, key) => {\r\n            obj[key] = activePlayers[key];\r\n            return obj;\r\n        }, {});\r\n        if (_activePlayersMoveLimit) {\r\n            // Remove player from _activePlayersMoveLimit.\r\n            _activePlayersMoveLimit = Object.keys(_activePlayersMoveLimit)\r\n                .filter((id) => id !== playerID)\r\n                .reduce((obj, key) => {\r\n                obj[key] = _activePlayersMoveLimit[key];\r\n                return obj;\r\n            }, {});\r\n        }\r\n        ctx = UpdateActivePlayersOnceEmpty({\r\n            ...ctx,\r\n            activePlayers,\r\n            _activePlayersMoveLimit,\r\n        });\r\n        // Add log entry.\r\n        const action = gameEvent('endStage', arg);\r\n        const logEntry = {\r\n            action,\r\n            _stateID: state._stateID,\r\n            turn: state.ctx.turn,\r\n            phase: state.ctx.phase,\r\n        };\r\n        if (automatic) {\r\n            logEntry.automatic = true;\r\n        }\r\n        const deltalog = [...(state.deltalog || []), logEntry];\r\n        return { ...state, ctx, deltalog };\r\n    }\r\n    /**\r\n     * Retrieves the relevant move that can be played by playerID.\r\n     *\r\n     * If ctx.activePlayers is set (i.e. one or more players are in some stage),\r\n     * then it attempts to find the move inside the stages config for\r\n     * that turn. If the stage for a player is '', then the player is\r\n     * allowed to make a move (as determined by the phase config), but\r\n     * isn't restricted to a particular set as defined in the stage config.\r\n     *\r\n     * If not, it then looks for the move inside the phase.\r\n     *\r\n     * If it doesn't find the move there, it looks at the global move definition.\r\n     *\r\n     * @param {object} ctx\r\n     * @param {string} name\r\n     * @param {string} playerID\r\n     */\r\n    function GetMove(ctx, name, playerID) {\r\n        const conf = GetPhase(ctx);\r\n        const stages = conf.turn.stages;\r\n        const { activePlayers } = ctx;\r\n        if (activePlayers &&\r\n            activePlayers[playerID] !== undefined &&\r\n            activePlayers[playerID] !== Stage.NULL &&\r\n            stages[activePlayers[playerID]] !== undefined &&\r\n            stages[activePlayers[playerID]].moves !== undefined) {\r\n            // Check if moves are defined for the player's stage.\r\n            const stage = stages[activePlayers[playerID]];\r\n            const moves = stage.moves;\r\n            if (name in moves) {\r\n                return moves[name];\r\n            }\r\n        }\r\n        else if (conf.moves) {\r\n            // Check if moves are defined for the current phase.\r\n            if (name in conf.moves) {\r\n                return conf.moves[name];\r\n            }\r\n        }\r\n        else if (name in moves) {\r\n            // Check for the move globally.\r\n            return moves[name];\r\n        }\r\n        return null;\r\n    }\r\n    function ProcessMove(state, action) {\r\n        const conf = GetPhase(state.ctx);\r\n        const move = GetMove(state.ctx, action.type, action.playerID);\r\n        const shouldCount = !move || typeof move === 'function' || move.noLimit !== true;\r\n        const { ctx } = state;\r\n        const { _activePlayersNumMoves } = ctx;\r\n        const { playerID } = action;\r\n        let numMoves = state.ctx.numMoves;\r\n        if (shouldCount) {\r\n            if (playerID == state.ctx.currentPlayer) {\r\n                numMoves++;\r\n            }\r\n            if (ctx.activePlayers)\r\n                _activePlayersNumMoves[playerID]++;\r\n        }\r\n        state = {\r\n            ...state,\r\n            ctx: {\r\n                ...ctx,\r\n                numMoves,\r\n                _activePlayersNumMoves,\r\n            },\r\n        };\r\n        if (ctx._activePlayersMoveLimit &&\r\n            _activePlayersNumMoves[playerID] >= ctx._activePlayersMoveLimit[playerID]) {\r\n            state = EndStage(state, { playerID, automatic: true });\r\n        }\r\n        const G = conf.turn.wrapped.onMove(state);\r\n        state = { ...state, G };\r\n        const events = [{ fn: OnMove }];\r\n        return Process(state, events);\r\n    }\r\n    function SetStageEvent(state, playerID, arg) {\r\n        return Process(state, [{ fn: EndStage, arg, playerID }]);\r\n    }\r\n    function EndStageEvent(state, playerID) {\r\n        return Process(state, [{ fn: EndStage, playerID }]);\r\n    }\r\n    function SetPhaseEvent(state, _playerID, newPhase) {\r\n        return Process(state, [\r\n            {\r\n                fn: EndPhase,\r\n                phase: state.ctx.phase,\r\n                turn: state.ctx.turn,\r\n                arg: { next: newPhase },\r\n            },\r\n        ]);\r\n    }\r\n    function EndPhaseEvent(state) {\r\n        return Process(state, [\r\n            { fn: EndPhase, phase: state.ctx.phase, turn: state.ctx.turn },\r\n        ]);\r\n    }\r\n    function EndTurnEvent(state, _playerID, arg) {\r\n        return Process(state, [\r\n            { fn: EndTurn, turn: state.ctx.turn, phase: state.ctx.phase, arg },\r\n        ]);\r\n    }\r\n    function PassEvent(state, _playerID, arg) {\r\n        return Process(state, [\r\n            {\r\n                fn: EndTurn,\r\n                turn: state.ctx.turn,\r\n                phase: state.ctx.phase,\r\n                force: true,\r\n                arg,\r\n            },\r\n        ]);\r\n    }\r\n    function EndGameEvent(state, _playerID, arg) {\r\n        return Process(state, [\r\n            { fn: EndGame, turn: state.ctx.turn, phase: state.ctx.phase, arg },\r\n        ]);\r\n    }\r\n    const eventHandlers = {\r\n        endStage: EndStageEvent,\r\n        setStage: SetStageEvent,\r\n        endTurn: EndTurnEvent,\r\n        pass: PassEvent,\r\n        endPhase: EndPhaseEvent,\r\n        setPhase: SetPhaseEvent,\r\n        endGame: EndGameEvent,\r\n        setActivePlayers: SetActivePlayersEvent,\r\n    };\r\n    const enabledEventNames = [];\r\n    if (events.endTurn !== false) {\r\n        enabledEventNames.push('endTurn');\r\n    }\r\n    if (events.pass !== false) {\r\n        enabledEventNames.push('pass');\r\n    }\r\n    if (events.endPhase !== false) {\r\n        enabledEventNames.push('endPhase');\r\n    }\r\n    if (events.setPhase !== false) {\r\n        enabledEventNames.push('setPhase');\r\n    }\r\n    if (events.endGame !== false) {\r\n        enabledEventNames.push('endGame');\r\n    }\r\n    if (events.setActivePlayers !== false) {\r\n        enabledEventNames.push('setActivePlayers');\r\n    }\r\n    if (events.endStage !== false) {\r\n        enabledEventNames.push('endStage');\r\n    }\r\n    if (events.setStage !== false) {\r\n        enabledEventNames.push('setStage');\r\n    }\r\n    function ProcessEvent(state, action) {\r\n        const { type, playerID, args } = action.payload;\r\n        if (Object.prototype.hasOwnProperty.call(eventHandlers, type)) {\r\n            const eventArgs = [state, playerID].concat(args);\r\n            return eventHandlers[type].apply({}, eventArgs);\r\n        }\r\n        return state;\r\n    }\r\n    function IsPlayerActive(_G, ctx, playerID) {\r\n        if (ctx.activePlayers) {\r\n            return playerID in ctx.activePlayers;\r\n        }\r\n        return ctx.currentPlayer === playerID;\r\n    }\r\n    return {\r\n        ctx: (numPlayers) => ({\r\n            numPlayers,\r\n            turn: 0,\r\n            currentPlayer: '0',\r\n            playOrder: [...new Array(numPlayers)].map((_d, i) => i + ''),\r\n            playOrderPos: 0,\r\n            phase: startingPhase,\r\n            activePlayers: null,\r\n        }),\r\n        init: (state) => {\r\n            return Process(state, [{ fn: StartGame }]);\r\n        },\r\n        isPlayerActive: IsPlayerActive,\r\n        eventHandlers,\r\n        eventNames: Object.keys(eventHandlers),\r\n        enabledEventNames,\r\n        moveMap,\r\n        moveNames: [...moveNames.values()],\r\n        processMove: ProcessMove,\r\n        processEvent: ProcessEvent,\r\n        getMove: GetMove,\r\n    };\r\n}\n\n/*\r\n * Copyright 2017 The boardgame.io Authors\r\n *\r\n * Use of this source code is governed by a MIT-style\r\n * license that can be found in the LICENSE file or at\r\n * https://opensource.org/licenses/MIT.\r\n */\r\nfunction IsProcessed(game) {\r\n    return game.processMove !== undefined;\r\n}\r\n/**\r\n * Helper to generate the game move reducer. The returned\r\n * reducer has the following signature:\r\n *\r\n * (G, action, ctx) => {}\r\n *\r\n * You can roll your own if you like, or use any Redux\r\n * addon to generate such a reducer.\r\n *\r\n * The convention used in this framework is to\r\n * have action.type contain the name of the move, and\r\n * action.args contain any additional arguments as an\r\n * Array.\r\n */\r\nfunction ProcessGameConfig(game) {\r\n    // The Game() function has already been called on this\r\n    // config object, so just pass it through.\r\n    if (IsProcessed(game)) {\r\n        return game;\r\n    }\r\n    if (game.name === undefined)\r\n        game.name = 'default';\r\n    if (game.deltaState === undefined)\r\n        game.deltaState = false;\r\n    if (game.disableUndo === undefined)\r\n        game.disableUndo = false;\r\n    if (game.setup === undefined)\r\n        game.setup = () => ({});\r\n    if (game.moves === undefined)\r\n        game.moves = {};\r\n    if (game.playerView === undefined)\r\n        game.playerView = (G) => G;\r\n    if (game.plugins === undefined)\r\n        game.plugins = [];\r\n    game.plugins.forEach((plugin) => {\r\n        if (plugin.name === undefined) {\r\n            throw new Error('Plugin missing name attribute');\r\n        }\r\n        if (plugin.name.includes(' ')) {\r\n            throw new Error(plugin.name + ': Plugin name must not include spaces');\r\n        }\r\n    });\r\n    if (game.name.includes(' ')) {\r\n        throw new Error(game.name + ': Game name must not include spaces');\r\n    }\r\n    const flow = Flow(game);\r\n    return {\r\n        ...game,\r\n        flow,\r\n        moveNames: flow.moveNames,\r\n        pluginNames: game.plugins.map((p) => p.name),\r\n        processMove: (state, action) => {\r\n            let moveFn = flow.getMove(state.ctx, action.type, action.playerID);\r\n            if (IsLongFormMove(moveFn)) {\r\n                moveFn = moveFn.move;\r\n            }\r\n            if (moveFn instanceof Function) {\r\n                const fn = FnWrap(moveFn, game.plugins);\r\n                const ctxWithAPI = {\r\n                    ...EnhanceCtx(state),\r\n                    playerID: action.playerID,\r\n                };\r\n                let args = [];\r\n                if (action.args !== undefined) {\r\n                    args = args.concat(action.args);\r\n                }\r\n                return fn(state.G, ctxWithAPI, ...args);\r\n            }\r\n            error(`invalid move object: ${action.type}`);\r\n            return state.G;\r\n        },\r\n    };\r\n}\r\nfunction IsLongFormMove(move) {\r\n    return move instanceof Object && move.move !== undefined;\r\n}\n\n/*\r\n * Copyright 2017 The boardgame.io Authors\r\n *\r\n * Use of this source code is governed by a MIT-style\r\n * license that can be found in the LICENSE file or at\r\n * https://opensource.org/licenses/MIT.\r\n */\r\nvar UpdateErrorType;\r\n(function (UpdateErrorType) {\r\n    // The action’s credentials were missing or invalid\r\n    UpdateErrorType[\"UnauthorizedAction\"] = \"update/unauthorized_action\";\r\n    // The action’s matchID was not found\r\n    UpdateErrorType[\"MatchNotFound\"] = \"update/match_not_found\";\r\n    // Could not apply Patch operation (rfc6902).\r\n    UpdateErrorType[\"PatchFailed\"] = \"update/patch_failed\";\r\n})(UpdateErrorType || (UpdateErrorType = {}));\r\nvar ActionErrorType;\r\n(function (ActionErrorType) {\r\n    // The action contained a stale state ID\r\n    ActionErrorType[\"StaleStateId\"] = \"action/stale_state_id\";\r\n    // The requested move is unknown or not currently available\r\n    ActionErrorType[\"UnavailableMove\"] = \"action/unavailable_move\";\r\n    // The move declared it was invalid (INVALID_MOVE constant)\r\n    ActionErrorType[\"InvalidMove\"] = \"action/invalid_move\";\r\n    // The player making the action is not currently active\r\n    ActionErrorType[\"InactivePlayer\"] = \"action/inactive_player\";\r\n    // The game has finished\r\n    ActionErrorType[\"GameOver\"] = \"action/gameover\";\r\n    // The requested action is disabled (e.g. undo/redo, events)\r\n    ActionErrorType[\"ActionDisabled\"] = \"action/action_disabled\";\r\n    // The requested action is not currently possible\r\n    ActionErrorType[\"ActionInvalid\"] = \"action/action_invalid\";\r\n})(ActionErrorType || (ActionErrorType = {}));\n\n/*\r\n * Copyright 2017 The boardgame.io Authors\r\n *\r\n * Use of this source code is governed by a MIT-style\r\n * license that can be found in the LICENSE file or at\r\n * https://opensource.org/licenses/MIT.\r\n */\r\n/**\r\n * Check if the payload for the passed action contains a playerID.\r\n */\r\nconst actionHasPlayerID = (action) => action.payload.playerID !== null && action.payload.playerID !== undefined;\r\n/**\r\n * Returns true if a move can be undone.\r\n */\r\nconst CanUndoMove = (G, ctx, move) => {\r\n    function HasUndoable(move) {\r\n        return move.undoable !== undefined;\r\n    }\r\n    function IsFunction(undoable) {\r\n        return undoable instanceof Function;\r\n    }\r\n    if (!HasUndoable(move)) {\r\n        return true;\r\n    }\r\n    if (IsFunction(move.undoable)) {\r\n        return move.undoable(G, ctx);\r\n    }\r\n    return move.undoable;\r\n};\r\n/**\r\n * Update the undo and redo stacks for a move or event.\r\n */\r\nfunction updateUndoRedoState(state, opts) {\r\n    if (opts.game.disableUndo)\r\n        return state;\r\n    const undoEntry = {\r\n        G: state.G,\r\n        ctx: state.ctx,\r\n        plugins: state.plugins,\r\n        playerID: opts.action.payload.playerID || state.ctx.currentPlayer,\r\n    };\r\n    if (opts.action.type === 'MAKE_MOVE') {\r\n        undoEntry.moveType = opts.action.payload.type;\r\n    }\r\n    return {\r\n        ...state,\r\n        _undo: [...state._undo, undoEntry],\r\n        // Always reset redo stack when making a move or event\r\n        _redo: [],\r\n    };\r\n}\r\n/**\r\n * Process state, adding the initial deltalog for this action.\r\n */\r\nfunction initializeDeltalog(state, action, move) {\r\n    // Create a log entry for this action.\r\n    const logEntry = {\r\n        action,\r\n        _stateID: state._stateID,\r\n        turn: state.ctx.turn,\r\n        phase: state.ctx.phase,\r\n    };\r\n    const pluginLogMetadata = state.plugins.log.data.metadata;\r\n    if (pluginLogMetadata !== undefined) {\r\n        logEntry.metadata = pluginLogMetadata;\r\n    }\r\n    if (typeof move === 'object' && move.redact === true) {\r\n        logEntry.redact = true;\r\n    }\r\n    return {\r\n        ...state,\r\n        deltalog: [logEntry],\r\n    };\r\n}\r\n/**\r\n * ExtractTransientsFromState\r\n *\r\n * Split out transients from the a TransientState\r\n */\r\nfunction ExtractTransients(transientState) {\r\n    if (!transientState) {\r\n        // We preserve null for the state for legacy callers, but the transient\r\n        // field should be undefined if not present to be consistent with the\r\n        // code path below.\r\n        return [null, undefined];\r\n    }\r\n    const { transients, ...state } = transientState;\r\n    return [state, transients];\r\n}\r\n/**\r\n * WithError\r\n *\r\n * Augment a State instance with transient error information.\r\n */\r\nfunction WithError(state, errorType, payload) {\r\n    const error = {\r\n        type: errorType,\r\n        payload,\r\n    };\r\n    return {\r\n        ...state,\r\n        transients: {\r\n            error,\r\n        },\r\n    };\r\n}\r\n/**\r\n * Middleware for processing TransientState associated with the reducer\r\n * returned by CreateGameReducer.\r\n * This should pretty much be used everywhere you want realistic state\r\n * transitions and error handling.\r\n */\r\nconst TransientHandlingMiddleware = (store) => (next) => (action) => {\r\n    const result = next(action);\r\n    switch (action.type) {\r\n        case STRIP_TRANSIENTS: {\r\n            return result;\r\n        }\r\n        default: {\r\n            const [, transients] = ExtractTransients(store.getState());\r\n            if (typeof transients !== 'undefined') {\r\n                store.dispatch(stripTransients());\r\n                // Dev Note: If parent middleware needs to correlate the spawned\r\n                // StripTransients action to the triggering action, instrument here.\r\n                //\r\n                // This is a bit tricky; for more details, see:\r\n                //   https://github.com/boardgameio/boardgame.io/pull/940#discussion_r636200648\r\n                return {\r\n                    ...result,\r\n                    transients,\r\n                };\r\n            }\r\n            return result;\r\n        }\r\n    }\r\n};\r\n/**\r\n * CreateGameReducer\r\n *\r\n * Creates the main game state reducer.\r\n */\r\nfunction CreateGameReducer({ game, isClient, }) {\r\n    game = ProcessGameConfig(game);\r\n    /**\r\n     * GameReducer\r\n     *\r\n     * Redux reducer that maintains the overall game state.\r\n     * @param {object} state - The state before the action.\r\n     * @param {object} action - A Redux action.\r\n     */\r\n    return (stateWithTransients = null, action) => {\r\n        let [state /*, transients */] = ExtractTransients(stateWithTransients);\r\n        switch (action.type) {\r\n            case STRIP_TRANSIENTS: {\r\n                // This action indicates that transient metadata in the state has been\r\n                // consumed and should now be stripped from the state..\r\n                return state;\r\n            }\r\n            case GAME_EVENT: {\r\n                state = { ...state, deltalog: [] };\r\n                // Process game events only on the server.\r\n                // These events like `endTurn` typically\r\n                // contain code that may rely on secret state\r\n                // and cannot be computed on the client.\r\n                if (isClient) {\r\n                    return state;\r\n                }\r\n                // Disallow events once the game is over.\r\n                if (state.ctx.gameover !== undefined) {\r\n                    error(`cannot call event after game end`);\r\n                    return WithError(state, ActionErrorType.GameOver);\r\n                }\r\n                // Ignore the event if the player isn't active.\r\n                if (actionHasPlayerID(action) &&\r\n                    !game.flow.isPlayerActive(state.G, state.ctx, action.payload.playerID)) {\r\n                    error(`disallowed event: ${action.payload.type}`);\r\n                    return WithError(state, ActionErrorType.InactivePlayer);\r\n                }\r\n                // Execute plugins.\r\n                state = Enhance(state, {\r\n                    game,\r\n                    isClient: false,\r\n                    playerID: action.payload.playerID,\r\n                });\r\n                // Process event.\r\n                let newState = game.flow.processEvent(state, action);\r\n                // Execute plugins.\r\n                newState = Flush(newState, { game, isClient: false });\r\n                // Update undo / redo state.\r\n                newState = updateUndoRedoState(newState, { game, action });\r\n                return { ...newState, _stateID: state._stateID + 1 };\r\n            }\r\n            case MAKE_MOVE: {\r\n                state = { ...state, deltalog: [] };\r\n                // Check whether the move is allowed at this time.\r\n                const move = game.flow.getMove(state.ctx, action.payload.type, action.payload.playerID || state.ctx.currentPlayer);\r\n                if (move === null) {\r\n                    error(`disallowed move: ${action.payload.type}`);\r\n                    return WithError(state, ActionErrorType.UnavailableMove);\r\n                }\r\n                // Don't run move on client if move says so.\r\n                if (isClient && move.client === false) {\r\n                    return state;\r\n                }\r\n                // Disallow moves once the game is over.\r\n                if (state.ctx.gameover !== undefined) {\r\n                    error(`cannot make move after game end`);\r\n                    return WithError(state, ActionErrorType.GameOver);\r\n                }\r\n                // Ignore the move if the player isn't active.\r\n                if (actionHasPlayerID(action) &&\r\n                    !game.flow.isPlayerActive(state.G, state.ctx, action.payload.playerID)) {\r\n                    error(`disallowed move: ${action.payload.type}`);\r\n                    return WithError(state, ActionErrorType.InactivePlayer);\r\n                }\r\n                // Execute plugins.\r\n                state = Enhance(state, {\r\n                    game,\r\n                    isClient,\r\n                    playerID: action.payload.playerID,\r\n                });\r\n                // Process the move.\r\n                const G = game.processMove(state, action.payload);\r\n                // The game declared the move as invalid.\r\n                if (G === INVALID_MOVE) {\r\n                    error(`invalid move: ${action.payload.type} args: ${action.payload.args}`);\r\n                    // TODO(#723): Marshal a nice error payload with the processed move.\r\n                    return WithError(state, ActionErrorType.InvalidMove);\r\n                }\r\n                const newState = { ...state, G };\r\n                // Some plugin indicated that it is not suitable to be\r\n                // materialized on the client (and must wait for the server\r\n                // response instead).\r\n                if (isClient && NoClient(newState, { game })) {\r\n                    return state;\r\n                }\r\n                state = newState;\r\n                // If we're on the client, just process the move\r\n                // and no triggers in multiplayer mode.\r\n                // These will be processed on the server, which\r\n                // will send back a state update.\r\n                if (isClient) {\r\n                    state = Flush(state, {\r\n                        game,\r\n                        isClient: true,\r\n                    });\r\n                    return {\r\n                        ...state,\r\n                        _stateID: state._stateID + 1,\r\n                    };\r\n                }\r\n                // On the server, construct the deltalog.\r\n                state = initializeDeltalog(state, action, move);\r\n                // Allow the flow reducer to process any triggers that happen after moves.\r\n                state = game.flow.processMove(state, action.payload);\r\n                state = Flush(state, { game });\r\n                // Update undo / redo state.\r\n                state = updateUndoRedoState(state, { game, action });\r\n                return {\r\n                    ...state,\r\n                    _stateID: state._stateID + 1,\r\n                };\r\n            }\r\n            case RESET:\r\n            case UPDATE:\r\n            case SYNC: {\r\n                return action.state;\r\n            }\r\n            case UNDO: {\r\n                state = { ...state, deltalog: [] };\r\n                if (game.disableUndo) {\r\n                    error('Undo is not enabled');\r\n                    return WithError(state, ActionErrorType.ActionDisabled);\r\n                }\r\n                const { _undo, _redo } = state;\r\n                if (_undo.length < 2) {\r\n                    error(`No moves to undo`);\r\n                    return WithError(state, ActionErrorType.ActionInvalid);\r\n                }\r\n                const last = _undo[_undo.length - 1];\r\n                const restore = _undo[_undo.length - 2];\r\n                // Only allow players to undo their own moves.\r\n                if (actionHasPlayerID(action) &&\r\n                    action.payload.playerID !== last.playerID) {\r\n                    error(`Cannot undo other players' moves`);\r\n                    return WithError(state, ActionErrorType.ActionInvalid);\r\n                }\r\n                // If undoing a move, check it is undoable.\r\n                if (last.moveType) {\r\n                    const lastMove = game.flow.getMove(restore.ctx, last.moveType, last.playerID);\r\n                    if (!CanUndoMove(state.G, state.ctx, lastMove)) {\r\n                        error(`Move cannot be undone`);\r\n                        return WithError(state, ActionErrorType.ActionInvalid);\r\n                    }\r\n                }\r\n                state = initializeDeltalog(state, action);\r\n                return {\r\n                    ...state,\r\n                    G: restore.G,\r\n                    ctx: restore.ctx,\r\n                    plugins: restore.plugins,\r\n                    _stateID: state._stateID + 1,\r\n                    _undo: _undo.slice(0, -1),\r\n                    _redo: [last, ..._redo],\r\n                };\r\n            }\r\n            case REDO: {\r\n                state = { ...state, deltalog: [] };\r\n                if (game.disableUndo) {\r\n                    error('Redo is not enabled');\r\n                    return WithError(state, ActionErrorType.ActionDisabled);\r\n                }\r\n                const { _undo, _redo } = state;\r\n                if (_redo.length == 0) {\r\n                    error(`No moves to redo`);\r\n                    return WithError(state, ActionErrorType.ActionInvalid);\r\n                }\r\n                const first = _redo[0];\r\n                // Only allow players to redo their own undos.\r\n                if (actionHasPlayerID(action) &&\r\n                    action.payload.playerID !== first.playerID) {\r\n                    error(`Cannot redo other players' moves`);\r\n                    return WithError(state, ActionErrorType.ActionInvalid);\r\n                }\r\n                state = initializeDeltalog(state, action);\r\n                return {\r\n                    ...state,\r\n                    G: first.G,\r\n                    ctx: first.ctx,\r\n                    plugins: first.plugins,\r\n                    _stateID: state._stateID + 1,\r\n                    _undo: [..._undo, first],\r\n                    _redo: _redo.slice(1),\r\n                };\r\n            }\r\n            case PLUGIN: {\r\n                // TODO(#723): Expose error semantics to plugin processing.\r\n                return ProcessAction(state, action, { game });\r\n            }\r\n            case PATCH: {\r\n                const oldState = state;\r\n                const newState = JSON.parse(JSON.stringify(oldState));\r\n                const patchError = applyPatch(newState, action.patch);\r\n                const hasError = patchError.some((entry) => entry !== null);\r\n                if (hasError) {\r\n                    error(`Patch ${JSON.stringify(action.patch)} apply failed`);\r\n                    return WithError(oldState, UpdateErrorType.PatchFailed, patchError);\r\n                }\r\n                else {\r\n                    return newState;\r\n                }\r\n            }\r\n            default: {\r\n                return state;\r\n            }\r\n        }\r\n    };\r\n}\n\nexport { CreateGameReducer as C, IsLongFormMove as I, ProcessGameConfig as P, TransientHandlingMiddleware as T };\n"]},"metadata":{},"sourceType":"module"}
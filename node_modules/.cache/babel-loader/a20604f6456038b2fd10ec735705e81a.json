{"ast":null,"code":"import { s as sync, B as update, t as reset, C as patch } from './turn-order-62966a9c.js';\nimport { T as Transport } from './transport-0079de87.js';\nimport { S as Sync } from './base-13e38c3e.js';\nimport { M as Master } from './master-41ed1c81.js';\nimport ioNamespace__default from 'socket.io-client';\n/*\r\n * Copyright 2017 The boardgame.io Authors\r\n *\r\n * Use of this source code is governed by a MIT-style\r\n * license that can be found in the LICENSE file or at\r\n * https://opensource.org/licenses/MIT.\r\n */\n\n/**\r\n * InMemory data storage.\r\n */\n\nclass InMemory extends Sync {\n  /**\r\n   * Creates a new InMemory storage.\r\n   */\n  constructor() {\n    super();\n    this.state = new Map();\n    this.initial = new Map();\n    this.metadata = new Map();\n    this.log = new Map();\n  }\n  /**\r\n   * Create a new match.\r\n   *\r\n   * @override\r\n   */\n\n\n  createMatch(matchID, opts) {\n    this.initial.set(matchID, opts.initialState);\n    this.setState(matchID, opts.initialState);\n    this.setMetadata(matchID, opts.metadata);\n  }\n  /**\r\n   * Write the match metadata to the in-memory object.\r\n   */\n\n\n  setMetadata(matchID, metadata) {\n    this.metadata.set(matchID, metadata);\n  }\n  /**\r\n   * Write the match state to the in-memory object.\r\n   */\n\n\n  setState(matchID, state, deltalog) {\n    if (deltalog && deltalog.length > 0) {\n      const log = this.log.get(matchID) || [];\n      this.log.set(matchID, log.concat(deltalog));\n    }\n\n    this.state.set(matchID, state);\n  }\n  /**\r\n   * Fetches state for a particular matchID.\r\n   */\n\n\n  fetch(matchID, opts) {\n    const result = {};\n\n    if (opts.state) {\n      result.state = this.state.get(matchID);\n    }\n\n    if (opts.metadata) {\n      result.metadata = this.metadata.get(matchID);\n    }\n\n    if (opts.log) {\n      result.log = this.log.get(matchID) || [];\n    }\n\n    if (opts.initialState) {\n      result.initialState = this.initial.get(matchID);\n    }\n\n    return result;\n  }\n  /**\r\n   * Remove the match state from the in-memory object.\r\n   */\n\n\n  wipe(matchID) {\n    this.state.delete(matchID);\n    this.metadata.delete(matchID);\n  }\n  /**\r\n   * Return all keys.\r\n   *\r\n   * @override\r\n   */\n\n\n  listMatches(opts) {\n    return [...this.metadata.entries()].filter(([, metadata]) => {\n      if (!opts) {\n        return true;\n      }\n\n      if (opts.gameName !== undefined && metadata.gameName !== opts.gameName) {\n        return false;\n      }\n\n      if (opts.where !== undefined) {\n        if (opts.where.isGameover !== undefined) {\n          const isGameover = metadata.gameover !== undefined;\n\n          if (isGameover !== opts.where.isGameover) {\n            return false;\n          }\n        }\n\n        if (opts.where.updatedBefore !== undefined && metadata.updatedAt >= opts.where.updatedBefore) {\n          return false;\n        }\n\n        if (opts.where.updatedAfter !== undefined && metadata.updatedAt <= opts.where.updatedAfter) {\n          return false;\n        }\n      }\n\n      return true;\n    }).map(([key]) => key);\n  }\n\n}\n\nclass WithLocalStorageMap extends Map {\n  constructor(key) {\n    super();\n    this.key = key;\n    const cache = JSON.parse(localStorage.getItem(this.key)) || [];\n    cache.forEach(entry => this.set(...entry));\n  }\n\n  sync() {\n    const entries = [...this.entries()];\n    localStorage.setItem(this.key, JSON.stringify(entries));\n  }\n\n  set(key, value) {\n    super.set(key, value);\n    this.sync();\n    return this;\n  }\n\n  delete(key) {\n    const result = super.delete(key);\n    this.sync();\n    return result;\n  }\n\n}\n/**\r\n * locaStorage data storage.\r\n */\n\n\nclass LocalStorage extends InMemory {\n  constructor(storagePrefix = 'bgio') {\n    super();\n\n    const StorageMap = stateKey => new WithLocalStorageMap(`${storagePrefix}_${stateKey}`);\n\n    this.state = StorageMap('state');\n    this.initial = StorageMap('initial');\n    this.metadata = StorageMap('metadata');\n    this.log = StorageMap('log');\n  }\n\n}\n/*\r\n * Copyright 2018 The boardgame.io Authors\r\n *\r\n * Use of this source code is governed by a MIT-style\r\n * license that can be found in the LICENSE file or at\r\n * https://opensource.org/licenses/MIT.\r\n */\n\n/**\r\n * Returns null if it is not a bot's turn.\r\n * Otherwise, returns a playerID of a bot that may play now.\r\n */\n\n\nfunction GetBotPlayer(state, bots) {\n  if (state.ctx.gameover !== undefined) {\n    return null;\n  }\n\n  if (state.ctx.activePlayers) {\n    for (const key of Object.keys(bots)) {\n      if (key in state.ctx.activePlayers) {\n        return key;\n      }\n    }\n  } else if (state.ctx.currentPlayer in bots) {\n    return state.ctx.currentPlayer;\n  }\n\n  return null;\n}\n/**\r\n * Creates a local version of the master that the client\r\n * can interact with.\r\n */\n\n\nclass LocalMaster extends Master {\n  constructor({\n    game,\n    bots,\n    storageKey,\n    persist\n  }) {\n    const clientCallbacks = {};\n    const initializedBots = {};\n\n    if (game && game.ai && bots) {\n      for (const playerID in bots) {\n        const bot = bots[playerID];\n        initializedBots[playerID] = new bot({\n          game,\n          enumerate: game.ai.enumerate,\n          seed: game.seed\n        });\n      }\n    }\n\n    const send = ({\n      playerID,\n      ...data\n    }) => {\n      const callback = clientCallbacks[playerID];\n\n      if (callback !== undefined) {\n        callback(data);\n      }\n    };\n\n    const transportAPI = {\n      send,\n      sendAll: makePlayerData => {\n        for (const playerID in clientCallbacks) {\n          const data = makePlayerData(playerID);\n          send({\n            playerID,\n            ...data\n          });\n        }\n      }\n    };\n    const storage = persist ? new LocalStorage(storageKey) : new InMemory();\n    super(game, storage, transportAPI);\n\n    this.connect = (matchID, playerID, callback) => {\n      clientCallbacks[playerID] = callback;\n    };\n\n    this.subscribe(({\n      state,\n      matchID\n    }) => {\n      if (!bots) {\n        return;\n      }\n\n      const botPlayer = GetBotPlayer(state, initializedBots);\n\n      if (botPlayer !== null) {\n        setTimeout(async () => {\n          const botAction = await initializedBots[botPlayer].play(state, botPlayer);\n          await this.onUpdate(botAction.action, state._stateID, matchID, botAction.action.payload.playerID);\n        }, 100);\n      }\n    });\n  }\n\n}\n/**\r\n * Local\r\n *\r\n * Transport interface that embeds a GameMaster within it\r\n * that you can connect multiple clients to.\r\n */\n\n\nclass LocalTransport extends Transport {\n  /**\r\n   * Creates a new Mutiplayer instance.\r\n   * @param {string} matchID - The game ID to connect to.\r\n   * @param {string} playerID - The player ID associated with this client.\r\n   * @param {string} gameName - The game type (the `name` field in `Game`).\r\n   * @param {string} numPlayers - The number of players.\r\n   */\n  constructor({\n    master,\n    ...opts\n  }) {\n    super(opts);\n    this.master = master;\n    this.isConnected = true;\n  }\n  /**\r\n   * Called when any player sends a chat message and the\r\n   * master broadcasts the update to other clients (including\r\n   * this one).\r\n   */\n\n\n  onChatMessage(matchID, chatMessage) {\n    const args = [matchID, chatMessage, this.credentials];\n    this.master.onChatMessage(...args);\n  }\n  /**\r\n   * Called when another player makes a move and the\r\n   * master broadcasts the update to other clients (including\r\n   * this one).\r\n   */\n\n\n  async onUpdate(matchID, state, deltalog) {\n    const currentState = this.store.getState();\n\n    if (matchID == this.matchID && state._stateID >= currentState._stateID) {\n      const action = update(state, deltalog);\n      this.store.dispatch(action);\n    }\n  }\n  /**\r\n   * Called when the client first connects to the master\r\n   * and requests the current game state.\r\n   */\n\n\n  onSync(matchID, syncInfo) {\n    if (matchID == this.matchID) {\n      const action = sync(syncInfo);\n      this.store.dispatch(action);\n    }\n  }\n  /**\r\n   * Called when an action that has to be relayed to the\r\n   * game master is made.\r\n   */\n\n\n  onAction(state, action) {\n    this.master.onUpdate(action, state._stateID, this.matchID, this.playerID);\n  }\n  /**\r\n   * Connect to the master.\r\n   */\n\n\n  connect() {\n    this.master.connect(this.matchID, this.playerID, data => {\n      switch (data.type) {\n        case 'sync':\n          return this.onSync(...data.args);\n\n        case 'update':\n          return this.onUpdate(...data.args);\n\n        case 'chat':\n          return this.chatMessageCallback(data.args[1]);\n      }\n    });\n    this.master.onSync(this.matchID, this.playerID, this.credentials, this.numPlayers);\n  }\n  /**\r\n   * Disconnect from the master.\r\n   */\n\n\n  disconnect() {}\n  /**\r\n   * Subscribe to connection state changes.\r\n   */\n\n\n  subscribe() {}\n\n  subscribeMatchData() {}\n\n  subscribeChatMessage(fn) {\n    this.chatMessageCallback = fn;\n  }\n  /**\r\n   * Dispatches a reset action, then requests a fresh sync from the master.\r\n   */\n\n\n  resetAndSync() {\n    const action = reset(null);\n    this.store.dispatch(action);\n    this.connect();\n  }\n  /**\r\n   * Updates the game id.\r\n   * @param {string} id - The new game id.\r\n   */\n\n\n  updateMatchID(id) {\n    this.matchID = id;\n    this.resetAndSync();\n  }\n  /**\r\n   * Updates the player associated with this client.\r\n   * @param {string} id - The new player id.\r\n   */\n\n\n  updatePlayerID(id) {\n    this.playerID = id;\n    this.resetAndSync();\n  }\n  /**\r\n   * Updates the credentials associated with this client.\r\n   * @param {string|undefined} credentials - The new credentials to use.\r\n   */\n\n\n  updateCredentials(credentials) {\n    this.credentials = credentials;\n    this.resetAndSync();\n  }\n\n}\n/**\r\n * Global map storing local master instances.\r\n */\n\n\nconst localMasters = new Map();\n/**\r\n * Create a local transport.\r\n */\n\nfunction Local({\n  bots,\n  persist,\n  storageKey\n} = {}) {\n  return transportOpts => {\n    const {\n      gameKey,\n      game\n    } = transportOpts;\n    let master;\n    const instance = localMasters.get(gameKey);\n\n    if (instance && instance.bots === bots && instance.storageKey === storageKey && instance.persist === persist) {\n      master = instance.master;\n    }\n\n    if (!master) {\n      master = new LocalMaster({\n        game,\n        bots,\n        persist,\n        storageKey\n      });\n      localMasters.set(gameKey, {\n        master,\n        bots,\n        persist,\n        storageKey\n      });\n    }\n\n    return new LocalTransport({\n      master,\n      ...transportOpts\n    });\n  };\n}\n/*\r\n * Copyright 2017 The boardgame.io Authors\r\n *\r\n * Use of this source code is governed by a MIT-style\r\n * license that can be found in the LICENSE file or at\r\n * https://opensource.org/licenses/MIT.\r\n */\n\n\nconst io = ioNamespace__default;\n/**\r\n * SocketIO\r\n *\r\n * Transport interface that interacts with the Master via socket.io.\r\n */\n\nclass SocketIOTransport extends Transport {\n  /**\r\n   * Creates a new Multiplayer instance.\r\n   * @param {object} socket - Override for unit tests.\r\n   * @param {object} socketOpts - Options to pass to socket.io.\r\n   * @param {object} store - Redux store\r\n   * @param {string} matchID - The game ID to connect to.\r\n   * @param {string} playerID - The player ID associated with this client.\r\n   * @param {string} credentials - Authentication credentials\r\n   * @param {string} gameName - The game type (the `name` field in `Game`).\r\n   * @param {string} numPlayers - The number of players.\r\n   * @param {string} server - The game server in the form of 'hostname:port'. Defaults to the server serving the client if not provided.\r\n   */\n  constructor({\n    socket,\n    socketOpts,\n    server,\n    ...opts\n  } = {}) {\n    super(opts);\n    this.server = server;\n    this.socket = socket;\n    this.socketOpts = socketOpts;\n    this.isConnected = false;\n\n    this.callback = () => {};\n\n    this.matchDataCallback = () => {};\n\n    this.chatMessageCallback = () => {};\n  }\n  /**\r\n   * Called when an action that has to be relayed to the\r\n   * game master is made.\r\n   */\n\n\n  onAction(state, action) {\n    const args = [action, state._stateID, this.matchID, this.playerID];\n    this.socket.emit('update', ...args);\n  }\n\n  onChatMessage(matchID, chatMessage) {\n    const args = [matchID, chatMessage, this.credentials];\n    this.socket.emit('chat', ...args);\n  }\n  /**\r\n   * Connect to the server.\r\n   */\n\n\n  connect() {\n    if (!this.socket) {\n      if (this.server) {\n        let server = this.server;\n\n        if (server.search(/^https?:\\/\\//) == -1) {\n          server = 'http://' + this.server;\n        }\n\n        if (server.slice(-1) != '/') {\n          // add trailing slash if not already present\n          server = server + '/';\n        }\n\n        this.socket = io(server + this.gameName, this.socketOpts);\n      } else {\n        this.socket = io('/' + this.gameName, this.socketOpts);\n      }\n    } // Called when another player makes a move and the\n    // master broadcasts the update as a patch to other clients (including\n    // this one).\n\n\n    this.socket.on('patch', (matchID, prevStateID, stateID, patch$1, deltalog) => {\n      const currentStateID = this.store.getState()._stateID;\n\n      if (matchID === this.matchID && prevStateID === currentStateID) {\n        const action = patch(prevStateID, stateID, patch$1, deltalog);\n        this.store.dispatch(action); // emit sync if patch apply failed\n\n        if (this.store.getState()._stateID === currentStateID) {\n          this.sync();\n        }\n      }\n    }); // Called when another player makes a move and the\n    // master broadcasts the update to other clients (including\n    // this one).\n\n    this.socket.on('update', (matchID, state, deltalog) => {\n      const currentState = this.store.getState();\n\n      if (matchID == this.matchID && state._stateID >= currentState._stateID) {\n        const action = update(state, deltalog);\n        this.store.dispatch(action);\n      }\n    }); // Called when the client first connects to the master\n    // and requests the current game state.\n\n    this.socket.on('sync', (matchID, syncInfo) => {\n      if (matchID == this.matchID) {\n        const action = sync(syncInfo);\n        this.matchDataCallback(syncInfo.filteredMetadata);\n        this.store.dispatch(action);\n      }\n    }); // Called when new player joins the match or changes\n    // it's connection status\n\n    this.socket.on('matchData', (matchID, matchData) => {\n      if (matchID == this.matchID) {\n        this.matchDataCallback(matchData);\n      }\n    });\n    this.socket.on('chat', (matchID, chatMessage) => {\n      if (matchID === this.matchID) {\n        this.chatMessageCallback(chatMessage);\n      }\n    }); // Keep track of connection status.\n\n    this.socket.on('connect', () => {\n      // Initial sync to get game state.\n      this.sync();\n      this.isConnected = true;\n      this.callback();\n    });\n    this.socket.on('disconnect', () => {\n      this.isConnected = false;\n      this.callback();\n    });\n  }\n  /**\r\n   * Disconnect from the server.\r\n   */\n\n\n  disconnect() {\n    this.socket.close();\n    this.socket = null;\n    this.isConnected = false;\n    this.callback();\n  }\n  /**\r\n   * Subscribe to connection state changes.\r\n   */\n\n\n  subscribe(fn) {\n    this.callback = fn;\n  }\n\n  subscribeMatchData(fn) {\n    this.matchDataCallback = fn;\n  }\n\n  subscribeChatMessage(fn) {\n    this.chatMessageCallback = fn;\n  }\n  /**\r\n   * Send a “sync” event to the server.\r\n   */\n\n\n  sync() {\n    if (this.socket) {\n      const args = [this.matchID, this.playerID, this.credentials, this.numPlayers];\n      this.socket.emit('sync', ...args);\n    }\n  }\n  /**\r\n   * Dispatches a reset action, then requests a fresh sync from the server.\r\n   */\n\n\n  resetAndSync() {\n    const action = reset(null);\n    this.store.dispatch(action);\n    this.sync();\n  }\n  /**\r\n   * Updates the game id.\r\n   * @param {string} id - The new game id.\r\n   */\n\n\n  updateMatchID(id) {\n    this.matchID = id;\n    this.resetAndSync();\n  }\n  /**\r\n   * Updates the player associated with this client.\r\n   * @param {string} id - The new player id.\r\n   */\n\n\n  updatePlayerID(id) {\n    this.playerID = id;\n    this.resetAndSync();\n  }\n  /**\r\n   * Updates the credentials associated with this client.\r\n   * @param {string|undefined} credentials - The new credentials to use.\r\n   */\n\n\n  updateCredentials(credentials) {\n    this.credentials = credentials;\n    this.resetAndSync();\n  }\n\n}\n\nfunction SocketIO({\n  server,\n  socketOpts\n} = {}) {\n  return transportOpts => new SocketIOTransport({\n    server,\n    socketOpts,\n    ...transportOpts\n  });\n}\n\nexport { Local as L, SocketIO as S };","map":{"version":3,"sources":["/Users/goldenowl/Desktop/example-boardgame/node_modules/boardgame.io/dist/esm/socketio-b63c9ee2.js"],"names":["s","sync","B","update","t","reset","C","patch","T","Transport","S","Sync","M","Master","ioNamespace__default","InMemory","constructor","state","Map","initial","metadata","log","createMatch","matchID","opts","set","initialState","setState","setMetadata","deltalog","length","get","concat","fetch","result","wipe","delete","listMatches","entries","filter","gameName","undefined","where","isGameover","gameover","updatedBefore","updatedAt","updatedAfter","map","key","WithLocalStorageMap","cache","JSON","parse","localStorage","getItem","forEach","entry","setItem","stringify","value","LocalStorage","storagePrefix","StorageMap","stateKey","GetBotPlayer","bots","ctx","activePlayers","Object","keys","currentPlayer","LocalMaster","game","storageKey","persist","clientCallbacks","initializedBots","ai","playerID","bot","enumerate","seed","send","data","callback","transportAPI","sendAll","makePlayerData","storage","connect","subscribe","botPlayer","setTimeout","botAction","play","onUpdate","action","_stateID","payload","LocalTransport","master","isConnected","onChatMessage","chatMessage","args","credentials","currentState","store","getState","dispatch","onSync","syncInfo","onAction","type","chatMessageCallback","numPlayers","disconnect","subscribeMatchData","subscribeChatMessage","fn","resetAndSync","updateMatchID","id","updatePlayerID","updateCredentials","localMasters","Local","transportOpts","gameKey","instance","io","SocketIOTransport","socket","socketOpts","server","matchDataCallback","emit","search","slice","on","prevStateID","stateID","patch$1","currentStateID","filteredMetadata","matchData","close","SocketIO","L"],"mappings":"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","sourcesContent":["import { s as sync, B as update, t as reset, C as patch } from './turn-order-62966a9c.js';\nimport { T as Transport } from './transport-0079de87.js';\nimport { S as Sync } from './base-13e38c3e.js';\nimport { M as Master } from './master-41ed1c81.js';\nimport ioNamespace__default from 'socket.io-client';\n\n/*\r\n * Copyright 2017 The boardgame.io Authors\r\n *\r\n * Use of this source code is governed by a MIT-style\r\n * license that can be found in the LICENSE file or at\r\n * https://opensource.org/licenses/MIT.\r\n */\r\n/**\r\n * InMemory data storage.\r\n */\r\nclass InMemory extends Sync {\r\n    /**\r\n     * Creates a new InMemory storage.\r\n     */\r\n    constructor() {\r\n        super();\r\n        this.state = new Map();\r\n        this.initial = new Map();\r\n        this.metadata = new Map();\r\n        this.log = new Map();\r\n    }\r\n    /**\r\n     * Create a new match.\r\n     *\r\n     * @override\r\n     */\r\n    createMatch(matchID, opts) {\r\n        this.initial.set(matchID, opts.initialState);\r\n        this.setState(matchID, opts.initialState);\r\n        this.setMetadata(matchID, opts.metadata);\r\n    }\r\n    /**\r\n     * Write the match metadata to the in-memory object.\r\n     */\r\n    setMetadata(matchID, metadata) {\r\n        this.metadata.set(matchID, metadata);\r\n    }\r\n    /**\r\n     * Write the match state to the in-memory object.\r\n     */\r\n    setState(matchID, state, deltalog) {\r\n        if (deltalog && deltalog.length > 0) {\r\n            const log = this.log.get(matchID) || [];\r\n            this.log.set(matchID, log.concat(deltalog));\r\n        }\r\n        this.state.set(matchID, state);\r\n    }\r\n    /**\r\n     * Fetches state for a particular matchID.\r\n     */\r\n    fetch(matchID, opts) {\r\n        const result = {};\r\n        if (opts.state) {\r\n            result.state = this.state.get(matchID);\r\n        }\r\n        if (opts.metadata) {\r\n            result.metadata = this.metadata.get(matchID);\r\n        }\r\n        if (opts.log) {\r\n            result.log = this.log.get(matchID) || [];\r\n        }\r\n        if (opts.initialState) {\r\n            result.initialState = this.initial.get(matchID);\r\n        }\r\n        return result;\r\n    }\r\n    /**\r\n     * Remove the match state from the in-memory object.\r\n     */\r\n    wipe(matchID) {\r\n        this.state.delete(matchID);\r\n        this.metadata.delete(matchID);\r\n    }\r\n    /**\r\n     * Return all keys.\r\n     *\r\n     * @override\r\n     */\r\n    listMatches(opts) {\r\n        return [...this.metadata.entries()]\r\n            .filter(([, metadata]) => {\r\n            if (!opts) {\r\n                return true;\r\n            }\r\n            if (opts.gameName !== undefined &&\r\n                metadata.gameName !== opts.gameName) {\r\n                return false;\r\n            }\r\n            if (opts.where !== undefined) {\r\n                if (opts.where.isGameover !== undefined) {\r\n                    const isGameover = metadata.gameover !== undefined;\r\n                    if (isGameover !== opts.where.isGameover) {\r\n                        return false;\r\n                    }\r\n                }\r\n                if (opts.where.updatedBefore !== undefined &&\r\n                    metadata.updatedAt >= opts.where.updatedBefore) {\r\n                    return false;\r\n                }\r\n                if (opts.where.updatedAfter !== undefined &&\r\n                    metadata.updatedAt <= opts.where.updatedAfter) {\r\n                    return false;\r\n                }\r\n            }\r\n            return true;\r\n        })\r\n            .map(([key]) => key);\r\n    }\r\n}\n\nclass WithLocalStorageMap extends Map {\r\n    constructor(key) {\r\n        super();\r\n        this.key = key;\r\n        const cache = JSON.parse(localStorage.getItem(this.key)) || [];\r\n        cache.forEach((entry) => this.set(...entry));\r\n    }\r\n    sync() {\r\n        const entries = [...this.entries()];\r\n        localStorage.setItem(this.key, JSON.stringify(entries));\r\n    }\r\n    set(key, value) {\r\n        super.set(key, value);\r\n        this.sync();\r\n        return this;\r\n    }\r\n    delete(key) {\r\n        const result = super.delete(key);\r\n        this.sync();\r\n        return result;\r\n    }\r\n}\r\n/**\r\n * locaStorage data storage.\r\n */\r\nclass LocalStorage extends InMemory {\r\n    constructor(storagePrefix = 'bgio') {\r\n        super();\r\n        const StorageMap = (stateKey) => new WithLocalStorageMap(`${storagePrefix}_${stateKey}`);\r\n        this.state = StorageMap('state');\r\n        this.initial = StorageMap('initial');\r\n        this.metadata = StorageMap('metadata');\r\n        this.log = StorageMap('log');\r\n    }\r\n}\n\n/*\r\n * Copyright 2018 The boardgame.io Authors\r\n *\r\n * Use of this source code is governed by a MIT-style\r\n * license that can be found in the LICENSE file or at\r\n * https://opensource.org/licenses/MIT.\r\n */\r\n/**\r\n * Returns null if it is not a bot's turn.\r\n * Otherwise, returns a playerID of a bot that may play now.\r\n */\r\nfunction GetBotPlayer(state, bots) {\r\n    if (state.ctx.gameover !== undefined) {\r\n        return null;\r\n    }\r\n    if (state.ctx.activePlayers) {\r\n        for (const key of Object.keys(bots)) {\r\n            if (key in state.ctx.activePlayers) {\r\n                return key;\r\n            }\r\n        }\r\n    }\r\n    else if (state.ctx.currentPlayer in bots) {\r\n        return state.ctx.currentPlayer;\r\n    }\r\n    return null;\r\n}\r\n/**\r\n * Creates a local version of the master that the client\r\n * can interact with.\r\n */\r\nclass LocalMaster extends Master {\r\n    constructor({ game, bots, storageKey, persist }) {\r\n        const clientCallbacks = {};\r\n        const initializedBots = {};\r\n        if (game && game.ai && bots) {\r\n            for (const playerID in bots) {\r\n                const bot = bots[playerID];\r\n                initializedBots[playerID] = new bot({\r\n                    game,\r\n                    enumerate: game.ai.enumerate,\r\n                    seed: game.seed,\r\n                });\r\n            }\r\n        }\r\n        const send = ({ playerID, ...data }) => {\r\n            const callback = clientCallbacks[playerID];\r\n            if (callback !== undefined) {\r\n                callback(data);\r\n            }\r\n        };\r\n        const transportAPI = {\r\n            send,\r\n            sendAll: (makePlayerData) => {\r\n                for (const playerID in clientCallbacks) {\r\n                    const data = makePlayerData(playerID);\r\n                    send({ playerID, ...data });\r\n                }\r\n            },\r\n        };\r\n        const storage = persist ? new LocalStorage(storageKey) : new InMemory();\r\n        super(game, storage, transportAPI);\r\n        this.connect = (matchID, playerID, callback) => {\r\n            clientCallbacks[playerID] = callback;\r\n        };\r\n        this.subscribe(({ state, matchID }) => {\r\n            if (!bots) {\r\n                return;\r\n            }\r\n            const botPlayer = GetBotPlayer(state, initializedBots);\r\n            if (botPlayer !== null) {\r\n                setTimeout(async () => {\r\n                    const botAction = await initializedBots[botPlayer].play(state, botPlayer);\r\n                    await this.onUpdate(botAction.action, state._stateID, matchID, botAction.action.payload.playerID);\r\n                }, 100);\r\n            }\r\n        });\r\n    }\r\n}\r\n/**\r\n * Local\r\n *\r\n * Transport interface that embeds a GameMaster within it\r\n * that you can connect multiple clients to.\r\n */\r\nclass LocalTransport extends Transport {\r\n    /**\r\n     * Creates a new Mutiplayer instance.\r\n     * @param {string} matchID - The game ID to connect to.\r\n     * @param {string} playerID - The player ID associated with this client.\r\n     * @param {string} gameName - The game type (the `name` field in `Game`).\r\n     * @param {string} numPlayers - The number of players.\r\n     */\r\n    constructor({ master, ...opts }) {\r\n        super(opts);\r\n        this.master = master;\r\n        this.isConnected = true;\r\n    }\r\n    /**\r\n     * Called when any player sends a chat message and the\r\n     * master broadcasts the update to other clients (including\r\n     * this one).\r\n     */\r\n    onChatMessage(matchID, chatMessage) {\r\n        const args = [\r\n            matchID,\r\n            chatMessage,\r\n            this.credentials,\r\n        ];\r\n        this.master.onChatMessage(...args);\r\n    }\r\n    /**\r\n     * Called when another player makes a move and the\r\n     * master broadcasts the update to other clients (including\r\n     * this one).\r\n     */\r\n    async onUpdate(matchID, state, deltalog) {\r\n        const currentState = this.store.getState();\r\n        if (matchID == this.matchID && state._stateID >= currentState._stateID) {\r\n            const action = update(state, deltalog);\r\n            this.store.dispatch(action);\r\n        }\r\n    }\r\n    /**\r\n     * Called when the client first connects to the master\r\n     * and requests the current game state.\r\n     */\r\n    onSync(matchID, syncInfo) {\r\n        if (matchID == this.matchID) {\r\n            const action = sync(syncInfo);\r\n            this.store.dispatch(action);\r\n        }\r\n    }\r\n    /**\r\n     * Called when an action that has to be relayed to the\r\n     * game master is made.\r\n     */\r\n    onAction(state, action) {\r\n        this.master.onUpdate(action, state._stateID, this.matchID, this.playerID);\r\n    }\r\n    /**\r\n     * Connect to the master.\r\n     */\r\n    connect() {\r\n        this.master.connect(this.matchID, this.playerID, (data) => {\r\n            switch (data.type) {\r\n                case 'sync':\r\n                    return this.onSync(...data.args);\r\n                case 'update':\r\n                    return this.onUpdate(...data.args);\r\n                case 'chat':\r\n                    return this.chatMessageCallback(data.args[1]);\r\n            }\r\n        });\r\n        this.master.onSync(this.matchID, this.playerID, this.credentials, this.numPlayers);\r\n    }\r\n    /**\r\n     * Disconnect from the master.\r\n     */\r\n    disconnect() { }\r\n    /**\r\n     * Subscribe to connection state changes.\r\n     */\r\n    subscribe() { }\r\n    subscribeMatchData() { }\r\n    subscribeChatMessage(fn) {\r\n        this.chatMessageCallback = fn;\r\n    }\r\n    /**\r\n     * Dispatches a reset action, then requests a fresh sync from the master.\r\n     */\r\n    resetAndSync() {\r\n        const action = reset(null);\r\n        this.store.dispatch(action);\r\n        this.connect();\r\n    }\r\n    /**\r\n     * Updates the game id.\r\n     * @param {string} id - The new game id.\r\n     */\r\n    updateMatchID(id) {\r\n        this.matchID = id;\r\n        this.resetAndSync();\r\n    }\r\n    /**\r\n     * Updates the player associated with this client.\r\n     * @param {string} id - The new player id.\r\n     */\r\n    updatePlayerID(id) {\r\n        this.playerID = id;\r\n        this.resetAndSync();\r\n    }\r\n    /**\r\n     * Updates the credentials associated with this client.\r\n     * @param {string|undefined} credentials - The new credentials to use.\r\n     */\r\n    updateCredentials(credentials) {\r\n        this.credentials = credentials;\r\n        this.resetAndSync();\r\n    }\r\n}\r\n/**\r\n * Global map storing local master instances.\r\n */\r\nconst localMasters = new Map();\r\n/**\r\n * Create a local transport.\r\n */\r\nfunction Local({ bots, persist, storageKey } = {}) {\r\n    return (transportOpts) => {\r\n        const { gameKey, game } = transportOpts;\r\n        let master;\r\n        const instance = localMasters.get(gameKey);\r\n        if (instance &&\r\n            instance.bots === bots &&\r\n            instance.storageKey === storageKey &&\r\n            instance.persist === persist) {\r\n            master = instance.master;\r\n        }\r\n        if (!master) {\r\n            master = new LocalMaster({ game, bots, persist, storageKey });\r\n            localMasters.set(gameKey, { master, bots, persist, storageKey });\r\n        }\r\n        return new LocalTransport({ master, ...transportOpts });\r\n    };\r\n}\n\n/*\r\n * Copyright 2017 The boardgame.io Authors\r\n *\r\n * Use of this source code is governed by a MIT-style\r\n * license that can be found in the LICENSE file or at\r\n * https://opensource.org/licenses/MIT.\r\n */\r\nconst io = ioNamespace__default;\r\n/**\r\n * SocketIO\r\n *\r\n * Transport interface that interacts with the Master via socket.io.\r\n */\r\nclass SocketIOTransport extends Transport {\r\n    /**\r\n     * Creates a new Multiplayer instance.\r\n     * @param {object} socket - Override for unit tests.\r\n     * @param {object} socketOpts - Options to pass to socket.io.\r\n     * @param {object} store - Redux store\r\n     * @param {string} matchID - The game ID to connect to.\r\n     * @param {string} playerID - The player ID associated with this client.\r\n     * @param {string} credentials - Authentication credentials\r\n     * @param {string} gameName - The game type (the `name` field in `Game`).\r\n     * @param {string} numPlayers - The number of players.\r\n     * @param {string} server - The game server in the form of 'hostname:port'. Defaults to the server serving the client if not provided.\r\n     */\r\n    constructor({ socket, socketOpts, server, ...opts } = {}) {\r\n        super(opts);\r\n        this.server = server;\r\n        this.socket = socket;\r\n        this.socketOpts = socketOpts;\r\n        this.isConnected = false;\r\n        this.callback = () => { };\r\n        this.matchDataCallback = () => { };\r\n        this.chatMessageCallback = () => { };\r\n    }\r\n    /**\r\n     * Called when an action that has to be relayed to the\r\n     * game master is made.\r\n     */\r\n    onAction(state, action) {\r\n        const args = [\r\n            action,\r\n            state._stateID,\r\n            this.matchID,\r\n            this.playerID,\r\n        ];\r\n        this.socket.emit('update', ...args);\r\n    }\r\n    onChatMessage(matchID, chatMessage) {\r\n        const args = [\r\n            matchID,\r\n            chatMessage,\r\n            this.credentials,\r\n        ];\r\n        this.socket.emit('chat', ...args);\r\n    }\r\n    /**\r\n     * Connect to the server.\r\n     */\r\n    connect() {\r\n        if (!this.socket) {\r\n            if (this.server) {\r\n                let server = this.server;\r\n                if (server.search(/^https?:\\/\\//) == -1) {\r\n                    server = 'http://' + this.server;\r\n                }\r\n                if (server.slice(-1) != '/') {\r\n                    // add trailing slash if not already present\r\n                    server = server + '/';\r\n                }\r\n                this.socket = io(server + this.gameName, this.socketOpts);\r\n            }\r\n            else {\r\n                this.socket = io('/' + this.gameName, this.socketOpts);\r\n            }\r\n        }\r\n        // Called when another player makes a move and the\r\n        // master broadcasts the update as a patch to other clients (including\r\n        // this one).\r\n        this.socket.on('patch', (matchID, prevStateID, stateID, patch$1, deltalog) => {\r\n            const currentStateID = this.store.getState()._stateID;\r\n            if (matchID === this.matchID && prevStateID === currentStateID) {\r\n                const action = patch(prevStateID, stateID, patch$1, deltalog);\r\n                this.store.dispatch(action);\r\n                // emit sync if patch apply failed\r\n                if (this.store.getState()._stateID === currentStateID) {\r\n                    this.sync();\r\n                }\r\n            }\r\n        });\r\n        // Called when another player makes a move and the\r\n        // master broadcasts the update to other clients (including\r\n        // this one).\r\n        this.socket.on('update', (matchID, state, deltalog) => {\r\n            const currentState = this.store.getState();\r\n            if (matchID == this.matchID &&\r\n                state._stateID >= currentState._stateID) {\r\n                const action = update(state, deltalog);\r\n                this.store.dispatch(action);\r\n            }\r\n        });\r\n        // Called when the client first connects to the master\r\n        // and requests the current game state.\r\n        this.socket.on('sync', (matchID, syncInfo) => {\r\n            if (matchID == this.matchID) {\r\n                const action = sync(syncInfo);\r\n                this.matchDataCallback(syncInfo.filteredMetadata);\r\n                this.store.dispatch(action);\r\n            }\r\n        });\r\n        // Called when new player joins the match or changes\r\n        // it's connection status\r\n        this.socket.on('matchData', (matchID, matchData) => {\r\n            if (matchID == this.matchID) {\r\n                this.matchDataCallback(matchData);\r\n            }\r\n        });\r\n        this.socket.on('chat', (matchID, chatMessage) => {\r\n            if (matchID === this.matchID) {\r\n                this.chatMessageCallback(chatMessage);\r\n            }\r\n        });\r\n        // Keep track of connection status.\r\n        this.socket.on('connect', () => {\r\n            // Initial sync to get game state.\r\n            this.sync();\r\n            this.isConnected = true;\r\n            this.callback();\r\n        });\r\n        this.socket.on('disconnect', () => {\r\n            this.isConnected = false;\r\n            this.callback();\r\n        });\r\n    }\r\n    /**\r\n     * Disconnect from the server.\r\n     */\r\n    disconnect() {\r\n        this.socket.close();\r\n        this.socket = null;\r\n        this.isConnected = false;\r\n        this.callback();\r\n    }\r\n    /**\r\n     * Subscribe to connection state changes.\r\n     */\r\n    subscribe(fn) {\r\n        this.callback = fn;\r\n    }\r\n    subscribeMatchData(fn) {\r\n        this.matchDataCallback = fn;\r\n    }\r\n    subscribeChatMessage(fn) {\r\n        this.chatMessageCallback = fn;\r\n    }\r\n    /**\r\n     * Send a “sync” event to the server.\r\n     */\r\n    sync() {\r\n        if (this.socket) {\r\n            const args = [\r\n                this.matchID,\r\n                this.playerID,\r\n                this.credentials,\r\n                this.numPlayers,\r\n            ];\r\n            this.socket.emit('sync', ...args);\r\n        }\r\n    }\r\n    /**\r\n     * Dispatches a reset action, then requests a fresh sync from the server.\r\n     */\r\n    resetAndSync() {\r\n        const action = reset(null);\r\n        this.store.dispatch(action);\r\n        this.sync();\r\n    }\r\n    /**\r\n     * Updates the game id.\r\n     * @param {string} id - The new game id.\r\n     */\r\n    updateMatchID(id) {\r\n        this.matchID = id;\r\n        this.resetAndSync();\r\n    }\r\n    /**\r\n     * Updates the player associated with this client.\r\n     * @param {string} id - The new player id.\r\n     */\r\n    updatePlayerID(id) {\r\n        this.playerID = id;\r\n        this.resetAndSync();\r\n    }\r\n    /**\r\n     * Updates the credentials associated with this client.\r\n     * @param {string|undefined} credentials - The new credentials to use.\r\n     */\r\n    updateCredentials(credentials) {\r\n        this.credentials = credentials;\r\n        this.resetAndSync();\r\n    }\r\n}\r\nfunction SocketIO({ server, socketOpts } = {}) {\r\n    return (transportOpts) => new SocketIOTransport({\r\n        server,\r\n        socketOpts,\r\n        ...transportOpts,\r\n    });\r\n}\n\nexport { Local as L, SocketIO as S };\n"]},"metadata":{},"sourceType":"module"}
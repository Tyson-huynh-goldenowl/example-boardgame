{"ast":null,"code":"import { applyMiddleware, createStore } from 'redux';\nimport { e as error, m as UNDO, n as REDO, M as MAKE_MOVE, w as PlayerView } from './turn-order-62966a9c.js';\nimport { P as ProcessGameConfig, C as CreateGameReducer, T as TransientHandlingMiddleware, I as IsLongFormMove } from './reducer-763b001e.js';\nimport { createPatch } from 'rfc6902';\nimport { I as InitializeGame } from './initialize-ca65fd4a.js';\nimport { i as isSynchronous } from './base-13e38c3e.js';\n/**\r\n * Creates a new match metadata object.\r\n */\n\nconst createMetadata = ({\n  game,\n  unlisted,\n  setupData,\n  numPlayers\n}) => {\n  const metadata = {\n    gameName: game.name,\n    unlisted: !!unlisted,\n    players: {},\n    createdAt: Date.now(),\n    updatedAt: Date.now()\n  };\n  if (setupData !== undefined) metadata.setupData = setupData;\n\n  for (let playerIndex = 0; playerIndex < numPlayers; playerIndex++) {\n    metadata.players[playerIndex] = {\n      id: playerIndex\n    };\n  }\n\n  return metadata;\n};\n/**\r\n * Creates matchID, initial state and metadata for a new match.\r\n * If the provided `setupData` doesn’t pass the game’s validation,\r\n * an error object is returned instead.\r\n */\n\n\nconst createMatch = ({\n  game,\n  numPlayers,\n  setupData,\n  unlisted\n}) => {\n  if (!numPlayers || typeof numPlayers !== 'number') numPlayers = 2;\n  const setupDataError = game.validateSetupData && game.validateSetupData(setupData, numPlayers);\n  if (setupDataError !== undefined) return {\n    setupDataError\n  };\n  const metadata = createMetadata({\n    game,\n    numPlayers,\n    setupData,\n    unlisted\n  });\n  const initialState = InitializeGame({\n    game,\n    numPlayers,\n    setupData\n  });\n  return {\n    metadata,\n    initialState\n  };\n};\n/*\r\n * Copyright 2018 The boardgame.io Authors\r\n *\r\n * Use of this source code is governed by a MIT-style\r\n * license that can be found in the LICENSE file or at\r\n * https://opensource.org/licenses/MIT.\r\n */\n\n/**\r\n * Filter match data to get a player metadata object with credentials stripped.\r\n */\n\n\nconst filterMatchData = matchData => Object.values(matchData.players).map(player => {\n  const {\n    credentials,\n    ...filteredData\n  } = player;\n  return filteredData;\n});\n/**\r\n * Redact the log.\r\n *\r\n * @param {Array} log - The game log (or deltalog).\r\n * @param {String} playerID - The playerID that this log is\r\n *                            to be sent to.\r\n */\n\n\nfunction redactLog(log, playerID) {\n  if (log === undefined) {\n    return log;\n  }\n\n  return log.map(logEvent => {\n    // filter for all other players and spectators.\n    if (playerID !== null && +playerID === +logEvent.action.payload.playerID) {\n      return logEvent;\n    }\n\n    if (logEvent.redact !== true) {\n      return logEvent;\n    }\n\n    const payload = { ...logEvent.action.payload,\n      args: null\n    };\n    const filteredEvent = { ...logEvent,\n      action: { ...logEvent.action,\n        payload\n      }\n    };\n    const {\n      redact,\n      ...remaining\n    } = filteredEvent;\n    return remaining;\n  });\n}\n/**\r\n * Remove player credentials from action payload\r\n */\n\n\nconst stripCredentialsFromAction = action => {\n  const {\n    credentials,\n    ...payload\n  } = action.payload;\n  return { ...action,\n    payload\n  };\n};\n/**\r\n * Master\r\n *\r\n * Class that runs the game and maintains the authoritative state.\r\n * It uses the transportAPI to communicate with clients and the\r\n * storageAPI to communicate with the database.\r\n */\n\n\nclass Master {\n  constructor(game, storageAPI, transportAPI, auth) {\n    this.game = ProcessGameConfig(game);\n    this.storageAPI = storageAPI;\n    this.transportAPI = transportAPI;\n\n    this.subscribeCallback = () => {};\n\n    this.auth = auth;\n  }\n\n  subscribe(fn) {\n    this.subscribeCallback = fn;\n  }\n  /**\r\n   * Called on each move / event made by the client.\r\n   * Computes the new value of the game state and returns it\r\n   * along with a deltalog.\r\n   */\n\n\n  async onUpdate(credAction, stateID, matchID, playerID) {\n    let metadata;\n\n    if (isSynchronous(this.storageAPI)) {\n      ({\n        metadata\n      } = this.storageAPI.fetch(matchID, {\n        metadata: true\n      }));\n    } else {\n      ({\n        metadata\n      } = await this.storageAPI.fetch(matchID, {\n        metadata: true\n      }));\n    }\n\n    if (this.auth) {\n      const isAuthentic = await this.auth.authenticateCredentials({\n        playerID,\n        credentials: credAction.payload.credentials,\n        metadata\n      });\n\n      if (!isAuthentic) {\n        return {\n          error: 'unauthorized action'\n        };\n      }\n    }\n\n    const action = stripCredentialsFromAction(credAction);\n    const key = matchID;\n    let state;\n\n    if (isSynchronous(this.storageAPI)) {\n      ({\n        state\n      } = this.storageAPI.fetch(key, {\n        state: true\n      }));\n    } else {\n      ({\n        state\n      } = await this.storageAPI.fetch(key, {\n        state: true\n      }));\n    }\n\n    if (state === undefined) {\n      error(`game not found, matchID=[${key}]`);\n      return {\n        error: 'game not found'\n      };\n    }\n\n    if (state.ctx.gameover !== undefined) {\n      error(`game over - matchID=[${key}] - playerID=[${playerID}]` + ` - action[${action.payload.type}]`);\n      return;\n    }\n\n    const reducer = CreateGameReducer({\n      game: this.game\n    });\n    const middleware = applyMiddleware(TransientHandlingMiddleware);\n    const store = createStore(reducer, state, middleware); // Only allow UNDO / REDO if there is exactly one player\n    // that can make moves right now and the person doing the\n    // action is that player.\n\n    if (action.type == UNDO || action.type == REDO) {\n      const hasActivePlayers = state.ctx.activePlayers !== null;\n      const isCurrentPlayer = state.ctx.currentPlayer === playerID;\n\n      if ( // If activePlayers is empty, non-current players can’t undo.\n      !hasActivePlayers && !isCurrentPlayer || // If player is not active or multiple players are active, can’t undo.\n      hasActivePlayers && (state.ctx.activePlayers[playerID] === undefined || Object.keys(state.ctx.activePlayers).length > 1)) {\n        error(`playerID=[${playerID}] cannot undo / redo right now`);\n        return;\n      }\n    } // Check whether the player is active.\n\n\n    if (!this.game.flow.isPlayerActive(state.G, state.ctx, playerID)) {\n      error(`player not active - playerID=[${playerID}]` + ` - action[${action.payload.type}]`);\n      return;\n    } // Get move for further checks\n\n\n    const move = action.type == MAKE_MOVE ? this.game.flow.getMove(state.ctx, action.payload.type, playerID) : null; // Check whether the player is allowed to make the move.\n\n    if (action.type == MAKE_MOVE && !move) {\n      error(`move not processed - canPlayerMakeMove=false - playerID=[${playerID}]` + ` - action[${action.payload.type}]`);\n      return;\n    } // Check if action's stateID is different than store's stateID\n    // and if move does not have ignoreStaleStateID truthy.\n\n\n    if (state._stateID !== stateID && !(move && IsLongFormMove(move) && move.ignoreStaleStateID)) {\n      error(`invalid stateID, was=[${stateID}], expected=[${state._stateID}]` + ` - playerID=[${playerID}] - action[${action.payload.type}]`);\n      return;\n    }\n\n    const prevState = store.getState(); // Update server's version of the store.\n\n    store.dispatch(action);\n    state = store.getState();\n    this.subscribeCallback({\n      state,\n      action,\n      matchID\n    });\n    this.transportAPI.sendAll(playerID => {\n      const log = redactLog(state.deltalog, playerID);\n      const filteredState = { ...state,\n        G: this.game.playerView(state.G, state.ctx, playerID),\n        plugins: PlayerView(state, {\n          playerID,\n          game: this.game\n        }),\n        deltalog: undefined,\n        _undo: [],\n        _redo: []\n      };\n\n      if (this.game.deltaState) {\n        const newStateID = state._stateID;\n        const prevFilteredState = { ...prevState,\n          G: this.game.playerView(prevState.G, prevState.ctx, playerID),\n          plugins: PlayerView(prevState, {\n            playerID,\n            game: this.game\n          }),\n          deltalog: undefined,\n          _undo: [],\n          _redo: []\n        };\n        const patch = createPatch(prevFilteredState, filteredState);\n        return {\n          type: 'patch',\n          args: [matchID, stateID, newStateID, patch, log]\n        };\n      } else {\n        return {\n          type: 'update',\n          args: [matchID, filteredState, log]\n        };\n      }\n    });\n    const {\n      deltalog,\n      ...stateWithoutDeltalog\n    } = state;\n    let newMetadata;\n\n    if (metadata && !('gameover' in metadata)) {\n      newMetadata = { ...metadata,\n        updatedAt: Date.now()\n      };\n\n      if (state.ctx.gameover !== undefined) {\n        newMetadata.gameover = state.ctx.gameover;\n      }\n    }\n\n    if (isSynchronous(this.storageAPI)) {\n      this.storageAPI.setState(key, stateWithoutDeltalog, deltalog);\n      if (newMetadata) this.storageAPI.setMetadata(key, newMetadata);\n    } else {\n      const writes = [this.storageAPI.setState(key, stateWithoutDeltalog, deltalog)];\n\n      if (newMetadata) {\n        writes.push(this.storageAPI.setMetadata(key, newMetadata));\n      }\n\n      await Promise.all(writes);\n    }\n  }\n  /**\r\n   * Called when the client connects / reconnects.\r\n   * Returns the latest game state and the entire log.\r\n   */\n\n\n  async onSync(matchID, playerID, credentials, numPlayers = 2) {\n    const key = matchID;\n    const fetchOpts = {\n      state: true,\n      metadata: true,\n      log: true,\n      initialState: true\n    };\n    const fetchResult = isSynchronous(this.storageAPI) ? this.storageAPI.fetch(key, fetchOpts) : await this.storageAPI.fetch(key, fetchOpts);\n    let {\n      state,\n      initialState,\n      log,\n      metadata\n    } = fetchResult;\n\n    if (this.auth && playerID !== undefined && playerID !== null) {\n      const isAuthentic = await this.auth.authenticateCredentials({\n        playerID,\n        credentials,\n        metadata\n      });\n\n      if (!isAuthentic) {\n        return {\n          error: 'unauthorized'\n        };\n      }\n    } // If the game doesn't exist, then create one on demand.\n    // TODO: Move this out of the sync call.\n\n\n    if (state === undefined) {\n      const match = createMatch({\n        game: this.game,\n        unlisted: true,\n        numPlayers,\n        setupData: undefined\n      });\n\n      if ('setupDataError' in match) {\n        return {\n          error: 'game requires setupData'\n        };\n      }\n\n      initialState = state = match.initialState;\n      metadata = match.metadata;\n      this.subscribeCallback({\n        state,\n        matchID\n      });\n\n      if (isSynchronous(this.storageAPI)) {\n        this.storageAPI.createMatch(key, {\n          initialState,\n          metadata\n        });\n      } else {\n        await this.storageAPI.createMatch(key, {\n          initialState,\n          metadata\n        });\n      }\n    }\n\n    const filteredMetadata = metadata ? filterMatchData(metadata) : undefined;\n    const filteredState = { ...state,\n      G: this.game.playerView(state.G, state.ctx, playerID),\n      plugins: PlayerView(state, {\n        playerID,\n        game: this.game\n      }),\n      deltalog: undefined,\n      _undo: [],\n      _redo: []\n    };\n    log = redactLog(log, playerID);\n    const syncInfo = {\n      state: filteredState,\n      log,\n      filteredMetadata,\n      initialState\n    };\n    this.transportAPI.send({\n      playerID,\n      type: 'sync',\n      args: [matchID, syncInfo]\n    });\n    return;\n  }\n  /**\r\n   * Called when a client connects or disconnects.\r\n   * Updates and sends out metadata to reflect the player’s connection status.\r\n   */\n\n\n  async onConnectionChange(matchID, playerID, credentials, connected) {\n    const key = matchID; // Ignore changes for clients without a playerID, e.g. spectators.\n\n    if (playerID === undefined || playerID === null) {\n      return;\n    }\n\n    let metadata;\n\n    if (isSynchronous(this.storageAPI)) {\n      ({\n        metadata\n      } = this.storageAPI.fetch(key, {\n        metadata: true\n      }));\n    } else {\n      ({\n        metadata\n      } = await this.storageAPI.fetch(key, {\n        metadata: true\n      }));\n    }\n\n    if (metadata === undefined) {\n      error(`metadata not found for matchID=[${key}]`);\n      return {\n        error: 'metadata not found'\n      };\n    }\n\n    if (metadata.players[playerID] === undefined) {\n      error(`Player not in the match, matchID=[${key}] playerID=[${playerID}]`);\n      return {\n        error: 'player not in the match'\n      };\n    }\n\n    if (this.auth) {\n      const isAuthentic = await this.auth.authenticateCredentials({\n        playerID,\n        credentials,\n        metadata\n      });\n\n      if (!isAuthentic) {\n        return {\n          error: 'unauthorized'\n        };\n      }\n    }\n\n    metadata.players[playerID].isConnected = connected;\n    const filteredMetadata = filterMatchData(metadata);\n    this.transportAPI.sendAll(() => ({\n      type: 'matchData',\n      args: [matchID, filteredMetadata]\n    }));\n\n    if (isSynchronous(this.storageAPI)) {\n      this.storageAPI.setMetadata(key, metadata);\n    } else {\n      await this.storageAPI.setMetadata(key, metadata);\n    }\n  }\n\n  async onChatMessage(matchID, chatMessage, credentials) {\n    const key = matchID;\n\n    if (this.auth) {\n      const {\n        metadata\n      } = await this.storageAPI.fetch(key, {\n        metadata: true\n      });\n      const isAuthentic = await this.auth.authenticateCredentials({\n        playerID: chatMessage.sender,\n        credentials,\n        metadata\n      });\n\n      if (!isAuthentic) {\n        return {\n          error: 'unauthorized'\n        };\n      }\n    }\n\n    this.transportAPI.sendAll(() => ({\n      type: 'chat',\n      args: [matchID, chatMessage]\n    }));\n  }\n\n}\n\nexport { Master as M };","map":{"version":3,"sources":["/Users/goldenowl/Desktop/example-boardgame/node_modules/boardgame.io/dist/esm/master-41ed1c81.js"],"names":["applyMiddleware","createStore","e","error","m","UNDO","n","REDO","M","MAKE_MOVE","w","PlayerView","P","ProcessGameConfig","C","CreateGameReducer","T","TransientHandlingMiddleware","I","IsLongFormMove","createPatch","InitializeGame","i","isSynchronous","createMetadata","game","unlisted","setupData","numPlayers","metadata","gameName","name","players","createdAt","Date","now","updatedAt","undefined","playerIndex","id","createMatch","setupDataError","validateSetupData","initialState","filterMatchData","matchData","Object","values","map","player","credentials","filteredData","redactLog","log","playerID","logEvent","action","payload","redact","args","filteredEvent","remaining","stripCredentialsFromAction","Master","constructor","storageAPI","transportAPI","auth","subscribeCallback","subscribe","fn","onUpdate","credAction","stateID","matchID","fetch","isAuthentic","authenticateCredentials","key","state","ctx","gameover","type","reducer","middleware","store","hasActivePlayers","activePlayers","isCurrentPlayer","currentPlayer","keys","length","flow","isPlayerActive","G","move","getMove","_stateID","ignoreStaleStateID","prevState","getState","dispatch","sendAll","deltalog","filteredState","playerView","plugins","_undo","_redo","deltaState","newStateID","prevFilteredState","patch","stateWithoutDeltalog","newMetadata","setState","setMetadata","writes","push","Promise","all","onSync","fetchOpts","fetchResult","match","filteredMetadata","syncInfo","send","onConnectionChange","connected","isConnected","onChatMessage","chatMessage","sender"],"mappings":"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","sourcesContent":["import { applyMiddleware, createStore } from 'redux';\nimport { e as error, m as UNDO, n as REDO, M as MAKE_MOVE, w as PlayerView } from './turn-order-62966a9c.js';\nimport { P as ProcessGameConfig, C as CreateGameReducer, T as TransientHandlingMiddleware, I as IsLongFormMove } from './reducer-763b001e.js';\nimport { createPatch } from 'rfc6902';\nimport { I as InitializeGame } from './initialize-ca65fd4a.js';\nimport { i as isSynchronous } from './base-13e38c3e.js';\n\n/**\r\n * Creates a new match metadata object.\r\n */\r\nconst createMetadata = ({ game, unlisted, setupData, numPlayers, }) => {\r\n    const metadata = {\r\n        gameName: game.name,\r\n        unlisted: !!unlisted,\r\n        players: {},\r\n        createdAt: Date.now(),\r\n        updatedAt: Date.now(),\r\n    };\r\n    if (setupData !== undefined)\r\n        metadata.setupData = setupData;\r\n    for (let playerIndex = 0; playerIndex < numPlayers; playerIndex++) {\r\n        metadata.players[playerIndex] = { id: playerIndex };\r\n    }\r\n    return metadata;\r\n};\r\n/**\r\n * Creates matchID, initial state and metadata for a new match.\r\n * If the provided `setupData` doesn’t pass the game’s validation,\r\n * an error object is returned instead.\r\n */\r\nconst createMatch = ({ game, numPlayers, setupData, unlisted, }) => {\r\n    if (!numPlayers || typeof numPlayers !== 'number')\r\n        numPlayers = 2;\r\n    const setupDataError = game.validateSetupData && game.validateSetupData(setupData, numPlayers);\r\n    if (setupDataError !== undefined)\r\n        return { setupDataError };\r\n    const metadata = createMetadata({ game, numPlayers, setupData, unlisted });\r\n    const initialState = InitializeGame({ game, numPlayers, setupData });\r\n    return { metadata, initialState };\r\n};\n\n/*\r\n * Copyright 2018 The boardgame.io Authors\r\n *\r\n * Use of this source code is governed by a MIT-style\r\n * license that can be found in the LICENSE file or at\r\n * https://opensource.org/licenses/MIT.\r\n */\r\n/**\r\n * Filter match data to get a player metadata object with credentials stripped.\r\n */\r\nconst filterMatchData = (matchData) => Object.values(matchData.players).map((player) => {\r\n    const { credentials, ...filteredData } = player;\r\n    return filteredData;\r\n});\r\n/**\r\n * Redact the log.\r\n *\r\n * @param {Array} log - The game log (or deltalog).\r\n * @param {String} playerID - The playerID that this log is\r\n *                            to be sent to.\r\n */\r\nfunction redactLog(log, playerID) {\r\n    if (log === undefined) {\r\n        return log;\r\n    }\r\n    return log.map((logEvent) => {\r\n        // filter for all other players and spectators.\r\n        if (playerID !== null && +playerID === +logEvent.action.payload.playerID) {\r\n            return logEvent;\r\n        }\r\n        if (logEvent.redact !== true) {\r\n            return logEvent;\r\n        }\r\n        const payload = {\r\n            ...logEvent.action.payload,\r\n            args: null,\r\n        };\r\n        const filteredEvent = {\r\n            ...logEvent,\r\n            action: { ...logEvent.action, payload },\r\n        };\r\n        const { redact, ...remaining } = filteredEvent;\r\n        return remaining;\r\n    });\r\n}\r\n/**\r\n * Remove player credentials from action payload\r\n */\r\nconst stripCredentialsFromAction = (action) => {\r\n    const { credentials, ...payload } = action.payload;\r\n    return { ...action, payload };\r\n};\r\n/**\r\n * Master\r\n *\r\n * Class that runs the game and maintains the authoritative state.\r\n * It uses the transportAPI to communicate with clients and the\r\n * storageAPI to communicate with the database.\r\n */\r\nclass Master {\r\n    constructor(game, storageAPI, transportAPI, auth) {\r\n        this.game = ProcessGameConfig(game);\r\n        this.storageAPI = storageAPI;\r\n        this.transportAPI = transportAPI;\r\n        this.subscribeCallback = () => { };\r\n        this.auth = auth;\r\n    }\r\n    subscribe(fn) {\r\n        this.subscribeCallback = fn;\r\n    }\r\n    /**\r\n     * Called on each move / event made by the client.\r\n     * Computes the new value of the game state and returns it\r\n     * along with a deltalog.\r\n     */\r\n    async onUpdate(credAction, stateID, matchID, playerID) {\r\n        let metadata;\r\n        if (isSynchronous(this.storageAPI)) {\r\n            ({ metadata } = this.storageAPI.fetch(matchID, { metadata: true }));\r\n        }\r\n        else {\r\n            ({ metadata } = await this.storageAPI.fetch(matchID, { metadata: true }));\r\n        }\r\n        if (this.auth) {\r\n            const isAuthentic = await this.auth.authenticateCredentials({\r\n                playerID,\r\n                credentials: credAction.payload.credentials,\r\n                metadata,\r\n            });\r\n            if (!isAuthentic) {\r\n                return { error: 'unauthorized action' };\r\n            }\r\n        }\r\n        const action = stripCredentialsFromAction(credAction);\r\n        const key = matchID;\r\n        let state;\r\n        if (isSynchronous(this.storageAPI)) {\r\n            ({ state } = this.storageAPI.fetch(key, { state: true }));\r\n        }\r\n        else {\r\n            ({ state } = await this.storageAPI.fetch(key, { state: true }));\r\n        }\r\n        if (state === undefined) {\r\n            error(`game not found, matchID=[${key}]`);\r\n            return { error: 'game not found' };\r\n        }\r\n        if (state.ctx.gameover !== undefined) {\r\n            error(`game over - matchID=[${key}] - playerID=[${playerID}]` +\r\n                ` - action[${action.payload.type}]`);\r\n            return;\r\n        }\r\n        const reducer = CreateGameReducer({\r\n            game: this.game,\r\n        });\r\n        const middleware = applyMiddleware(TransientHandlingMiddleware);\r\n        const store = createStore(reducer, state, middleware);\r\n        // Only allow UNDO / REDO if there is exactly one player\r\n        // that can make moves right now and the person doing the\r\n        // action is that player.\r\n        if (action.type == UNDO || action.type == REDO) {\r\n            const hasActivePlayers = state.ctx.activePlayers !== null;\r\n            const isCurrentPlayer = state.ctx.currentPlayer === playerID;\r\n            if (\r\n            // If activePlayers is empty, non-current players can’t undo.\r\n            (!hasActivePlayers && !isCurrentPlayer) ||\r\n                // If player is not active or multiple players are active, can’t undo.\r\n                (hasActivePlayers &&\r\n                    (state.ctx.activePlayers[playerID] === undefined ||\r\n                        Object.keys(state.ctx.activePlayers).length > 1))) {\r\n                error(`playerID=[${playerID}] cannot undo / redo right now`);\r\n                return;\r\n            }\r\n        }\r\n        // Check whether the player is active.\r\n        if (!this.game.flow.isPlayerActive(state.G, state.ctx, playerID)) {\r\n            error(`player not active - playerID=[${playerID}]` +\r\n                ` - action[${action.payload.type}]`);\r\n            return;\r\n        }\r\n        // Get move for further checks\r\n        const move = action.type == MAKE_MOVE\r\n            ? this.game.flow.getMove(state.ctx, action.payload.type, playerID)\r\n            : null;\r\n        // Check whether the player is allowed to make the move.\r\n        if (action.type == MAKE_MOVE && !move) {\r\n            error(`move not processed - canPlayerMakeMove=false - playerID=[${playerID}]` +\r\n                ` - action[${action.payload.type}]`);\r\n            return;\r\n        }\r\n        // Check if action's stateID is different than store's stateID\r\n        // and if move does not have ignoreStaleStateID truthy.\r\n        if (state._stateID !== stateID &&\r\n            !(move && IsLongFormMove(move) && move.ignoreStaleStateID)) {\r\n            error(`invalid stateID, was=[${stateID}], expected=[${state._stateID}]` +\r\n                ` - playerID=[${playerID}] - action[${action.payload.type}]`);\r\n            return;\r\n        }\r\n        const prevState = store.getState();\r\n        // Update server's version of the store.\r\n        store.dispatch(action);\r\n        state = store.getState();\r\n        this.subscribeCallback({\r\n            state,\r\n            action,\r\n            matchID,\r\n        });\r\n        this.transportAPI.sendAll((playerID) => {\r\n            const log = redactLog(state.deltalog, playerID);\r\n            const filteredState = {\r\n                ...state,\r\n                G: this.game.playerView(state.G, state.ctx, playerID),\r\n                plugins: PlayerView(state, { playerID, game: this.game }),\r\n                deltalog: undefined,\r\n                _undo: [],\r\n                _redo: [],\r\n            };\r\n            if (this.game.deltaState) {\r\n                const newStateID = state._stateID;\r\n                const prevFilteredState = {\r\n                    ...prevState,\r\n                    G: this.game.playerView(prevState.G, prevState.ctx, playerID),\r\n                    plugins: PlayerView(prevState, { playerID, game: this.game }),\r\n                    deltalog: undefined,\r\n                    _undo: [],\r\n                    _redo: [],\r\n                };\r\n                const patch = createPatch(prevFilteredState, filteredState);\r\n                return {\r\n                    type: 'patch',\r\n                    args: [matchID, stateID, newStateID, patch, log],\r\n                };\r\n            }\r\n            else {\r\n                return {\r\n                    type: 'update',\r\n                    args: [matchID, filteredState, log],\r\n                };\r\n            }\r\n        });\r\n        const { deltalog, ...stateWithoutDeltalog } = state;\r\n        let newMetadata;\r\n        if (metadata && !('gameover' in metadata)) {\r\n            newMetadata = {\r\n                ...metadata,\r\n                updatedAt: Date.now(),\r\n            };\r\n            if (state.ctx.gameover !== undefined) {\r\n                newMetadata.gameover = state.ctx.gameover;\r\n            }\r\n        }\r\n        if (isSynchronous(this.storageAPI)) {\r\n            this.storageAPI.setState(key, stateWithoutDeltalog, deltalog);\r\n            if (newMetadata)\r\n                this.storageAPI.setMetadata(key, newMetadata);\r\n        }\r\n        else {\r\n            const writes = [\r\n                this.storageAPI.setState(key, stateWithoutDeltalog, deltalog),\r\n            ];\r\n            if (newMetadata) {\r\n                writes.push(this.storageAPI.setMetadata(key, newMetadata));\r\n            }\r\n            await Promise.all(writes);\r\n        }\r\n    }\r\n    /**\r\n     * Called when the client connects / reconnects.\r\n     * Returns the latest game state and the entire log.\r\n     */\r\n    async onSync(matchID, playerID, credentials, numPlayers = 2) {\r\n        const key = matchID;\r\n        const fetchOpts = {\r\n            state: true,\r\n            metadata: true,\r\n            log: true,\r\n            initialState: true,\r\n        };\r\n        const fetchResult = isSynchronous(this.storageAPI)\r\n            ? this.storageAPI.fetch(key, fetchOpts)\r\n            : await this.storageAPI.fetch(key, fetchOpts);\r\n        let { state, initialState, log, metadata } = fetchResult;\r\n        if (this.auth && playerID !== undefined && playerID !== null) {\r\n            const isAuthentic = await this.auth.authenticateCredentials({\r\n                playerID,\r\n                credentials,\r\n                metadata,\r\n            });\r\n            if (!isAuthentic) {\r\n                return { error: 'unauthorized' };\r\n            }\r\n        }\r\n        // If the game doesn't exist, then create one on demand.\r\n        // TODO: Move this out of the sync call.\r\n        if (state === undefined) {\r\n            const match = createMatch({\r\n                game: this.game,\r\n                unlisted: true,\r\n                numPlayers,\r\n                setupData: undefined,\r\n            });\r\n            if ('setupDataError' in match) {\r\n                return { error: 'game requires setupData' };\r\n            }\r\n            initialState = state = match.initialState;\r\n            metadata = match.metadata;\r\n            this.subscribeCallback({ state, matchID });\r\n            if (isSynchronous(this.storageAPI)) {\r\n                this.storageAPI.createMatch(key, { initialState, metadata });\r\n            }\r\n            else {\r\n                await this.storageAPI.createMatch(key, { initialState, metadata });\r\n            }\r\n        }\r\n        const filteredMetadata = metadata ? filterMatchData(metadata) : undefined;\r\n        const filteredState = {\r\n            ...state,\r\n            G: this.game.playerView(state.G, state.ctx, playerID),\r\n            plugins: PlayerView(state, { playerID, game: this.game }),\r\n            deltalog: undefined,\r\n            _undo: [],\r\n            _redo: [],\r\n        };\r\n        log = redactLog(log, playerID);\r\n        const syncInfo = {\r\n            state: filteredState,\r\n            log,\r\n            filteredMetadata,\r\n            initialState,\r\n        };\r\n        this.transportAPI.send({\r\n            playerID,\r\n            type: 'sync',\r\n            args: [matchID, syncInfo],\r\n        });\r\n        return;\r\n    }\r\n    /**\r\n     * Called when a client connects or disconnects.\r\n     * Updates and sends out metadata to reflect the player’s connection status.\r\n     */\r\n    async onConnectionChange(matchID, playerID, credentials, connected) {\r\n        const key = matchID;\r\n        // Ignore changes for clients without a playerID, e.g. spectators.\r\n        if (playerID === undefined || playerID === null) {\r\n            return;\r\n        }\r\n        let metadata;\r\n        if (isSynchronous(this.storageAPI)) {\r\n            ({ metadata } = this.storageAPI.fetch(key, { metadata: true }));\r\n        }\r\n        else {\r\n            ({ metadata } = await this.storageAPI.fetch(key, { metadata: true }));\r\n        }\r\n        if (metadata === undefined) {\r\n            error(`metadata not found for matchID=[${key}]`);\r\n            return { error: 'metadata not found' };\r\n        }\r\n        if (metadata.players[playerID] === undefined) {\r\n            error(`Player not in the match, matchID=[${key}] playerID=[${playerID}]`);\r\n            return { error: 'player not in the match' };\r\n        }\r\n        if (this.auth) {\r\n            const isAuthentic = await this.auth.authenticateCredentials({\r\n                playerID,\r\n                credentials,\r\n                metadata,\r\n            });\r\n            if (!isAuthentic) {\r\n                return { error: 'unauthorized' };\r\n            }\r\n        }\r\n        metadata.players[playerID].isConnected = connected;\r\n        const filteredMetadata = filterMatchData(metadata);\r\n        this.transportAPI.sendAll(() => ({\r\n            type: 'matchData',\r\n            args: [matchID, filteredMetadata],\r\n        }));\r\n        if (isSynchronous(this.storageAPI)) {\r\n            this.storageAPI.setMetadata(key, metadata);\r\n        }\r\n        else {\r\n            await this.storageAPI.setMetadata(key, metadata);\r\n        }\r\n    }\r\n    async onChatMessage(matchID, chatMessage, credentials) {\r\n        const key = matchID;\r\n        if (this.auth) {\r\n            const { metadata } = await this.storageAPI.fetch(key, {\r\n                metadata: true,\r\n            });\r\n            const isAuthentic = await this.auth.authenticateCredentials({\r\n                playerID: chatMessage.sender,\r\n                credentials,\r\n                metadata,\r\n            });\r\n            if (!isAuthentic) {\r\n                return { error: 'unauthorized' };\r\n            }\r\n        }\r\n        this.transportAPI.sendAll(() => ({\r\n            type: 'chat',\r\n            args: [matchID, chatMessage],\r\n        }));\r\n    }\r\n}\n\nexport { Master as M };\n"]},"metadata":{},"sourceType":"module"}
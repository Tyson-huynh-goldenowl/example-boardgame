{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.clone = exports.objectType = exports.hasOwnProperty = void 0;\nexports.hasOwnProperty = Object.prototype.hasOwnProperty;\n\nfunction objectType(object) {\n  if (object === undefined) {\n    return 'undefined';\n  }\n\n  if (object === null) {\n    return 'null';\n  }\n\n  if (Array.isArray(object)) {\n    return 'array';\n  }\n\n  return typeof object;\n}\n\nexports.objectType = objectType;\n\nfunction isNonPrimitive(value) {\n  // loose-equality checking for null is faster than strict checking for each of null/undefined/true/false\n  // checking null first, then calling typeof, is faster than vice-versa\n  return value != null && typeof value == 'object';\n}\n/**\nRecursively copy a value.\n\n@param source - should be a JavaScript primitive, Array, Date, or (plain old) Object.\n@returns copy of source where every Array and Object have been recursively\n         reconstructed from their constituent elements\n*/\n\n\nfunction clone(source) {\n  if (!isNonPrimitive(source)) {\n    // short-circuiting is faster than a single return\n    return source;\n  } // x.constructor == Array is the fastest way to check if x is an Array\n\n\n  if (source.constructor == Array) {\n    // construction via imperative for-loop is faster than source.map(arrayVsObject)\n    var length_1 = source.length; // setting the Array length during construction is faster than just `[]` or `new Array()`\n\n    var arrayTarget = new Array(length_1);\n\n    for (var i = 0; i < length_1; i++) {\n      arrayTarget[i] = clone(source[i]);\n    }\n\n    return arrayTarget;\n  } // Date\n\n\n  if (source.constructor == Date) {\n    var dateTarget = new Date(+source);\n    return dateTarget;\n  } // Object\n\n\n  var objectTarget = {}; // declaring the variable (with const) inside the loop is faster\n\n  for (var key in source) {\n    // hasOwnProperty costs a bit of performance, but it's semantically necessary\n    // using a global helper is MUCH faster than calling source.hasOwnProperty(key)\n    if (exports.hasOwnProperty.call(source, key)) {\n      objectTarget[key] = clone(source[key]);\n    }\n  }\n\n  return objectTarget;\n}\n\nexports.clone = clone;","map":{"version":3,"sources":["/Users/goldenowl/Desktop/example-boardgame/node_modules/rfc6902/util.js"],"names":["Object","defineProperty","exports","value","clone","objectType","hasOwnProperty","prototype","object","undefined","Array","isArray","isNonPrimitive","source","constructor","length_1","length","arrayTarget","i","Date","dateTarget","objectTarget","key","call"],"mappings":"AAAA;;AACAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAAEC,EAAAA,KAAK,EAAE;AAAT,CAA7C;AACAD,OAAO,CAACE,KAAR,GAAgBF,OAAO,CAACG,UAAR,GAAqBH,OAAO,CAACI,cAAR,GAAyB,KAAK,CAAnE;AACAJ,OAAO,CAACI,cAAR,GAAyBN,MAAM,CAACO,SAAP,CAAiBD,cAA1C;;AACA,SAASD,UAAT,CAAoBG,MAApB,EAA4B;AACxB,MAAIA,MAAM,KAAKC,SAAf,EAA0B;AACtB,WAAO,WAAP;AACH;;AACD,MAAID,MAAM,KAAK,IAAf,EAAqB;AACjB,WAAO,MAAP;AACH;;AACD,MAAIE,KAAK,CAACC,OAAN,CAAcH,MAAd,CAAJ,EAA2B;AACvB,WAAO,OAAP;AACH;;AACD,SAAO,OAAOA,MAAd;AACH;;AACDN,OAAO,CAACG,UAAR,GAAqBA,UAArB;;AACA,SAASO,cAAT,CAAwBT,KAAxB,EAA+B;AAC3B;AACA;AACA,SAAOA,KAAK,IAAI,IAAT,IAAiB,OAAOA,KAAP,IAAgB,QAAxC;AACH;AACD;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASC,KAAT,CAAeS,MAAf,EAAuB;AACnB,MAAI,CAACD,cAAc,CAACC,MAAD,CAAnB,EAA6B;AACzB;AACA,WAAOA,MAAP;AACH,GAJkB,CAKnB;;;AACA,MAAIA,MAAM,CAACC,WAAP,IAAsBJ,KAA1B,EAAiC;AAC7B;AACA,QAAIK,QAAQ,GAAGF,MAAM,CAACG,MAAtB,CAF6B,CAG7B;;AACA,QAAIC,WAAW,GAAG,IAAIP,KAAJ,CAAUK,QAAV,CAAlB;;AACA,SAAK,IAAIG,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGH,QAApB,EAA8BG,CAAC,EAA/B,EAAmC;AAC/BD,MAAAA,WAAW,CAACC,CAAD,CAAX,GAAiBd,KAAK,CAACS,MAAM,CAACK,CAAD,CAAP,CAAtB;AACH;;AACD,WAAOD,WAAP;AACH,GAfkB,CAgBnB;;;AACA,MAAIJ,MAAM,CAACC,WAAP,IAAsBK,IAA1B,EAAgC;AAC5B,QAAIC,UAAU,GAAG,IAAID,IAAJ,CAAS,CAACN,MAAV,CAAjB;AACA,WAAOO,UAAP;AACH,GApBkB,CAqBnB;;;AACA,MAAIC,YAAY,GAAG,EAAnB,CAtBmB,CAuBnB;;AACA,OAAK,IAAIC,GAAT,IAAgBT,MAAhB,EAAwB;AACpB;AACA;AACA,QAAIX,OAAO,CAACI,cAAR,CAAuBiB,IAAvB,CAA4BV,MAA5B,EAAoCS,GAApC,CAAJ,EAA8C;AAC1CD,MAAAA,YAAY,CAACC,GAAD,CAAZ,GAAoBlB,KAAK,CAACS,MAAM,CAACS,GAAD,CAAP,CAAzB;AACH;AACJ;;AACD,SAAOD,YAAP;AACH;;AACDnB,OAAO,CAACE,KAAR,GAAgBA,KAAhB","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.clone = exports.objectType = exports.hasOwnProperty = void 0;\nexports.hasOwnProperty = Object.prototype.hasOwnProperty;\nfunction objectType(object) {\n    if (object === undefined) {\n        return 'undefined';\n    }\n    if (object === null) {\n        return 'null';\n    }\n    if (Array.isArray(object)) {\n        return 'array';\n    }\n    return typeof object;\n}\nexports.objectType = objectType;\nfunction isNonPrimitive(value) {\n    // loose-equality checking for null is faster than strict checking for each of null/undefined/true/false\n    // checking null first, then calling typeof, is faster than vice-versa\n    return value != null && typeof value == 'object';\n}\n/**\nRecursively copy a value.\n\n@param source - should be a JavaScript primitive, Array, Date, or (plain old) Object.\n@returns copy of source where every Array and Object have been recursively\n         reconstructed from their constituent elements\n*/\nfunction clone(source) {\n    if (!isNonPrimitive(source)) {\n        // short-circuiting is faster than a single return\n        return source;\n    }\n    // x.constructor == Array is the fastest way to check if x is an Array\n    if (source.constructor == Array) {\n        // construction via imperative for-loop is faster than source.map(arrayVsObject)\n        var length_1 = source.length;\n        // setting the Array length during construction is faster than just `[]` or `new Array()`\n        var arrayTarget = new Array(length_1);\n        for (var i = 0; i < length_1; i++) {\n            arrayTarget[i] = clone(source[i]);\n        }\n        return arrayTarget;\n    }\n    // Date\n    if (source.constructor == Date) {\n        var dateTarget = new Date(+source);\n        return dateTarget;\n    }\n    // Object\n    var objectTarget = {};\n    // declaring the variable (with const) inside the loop is faster\n    for (var key in source) {\n        // hasOwnProperty costs a bit of performance, but it's semantically necessary\n        // using a global helper is MUCH faster than calling source.hasOwnProperty(key)\n        if (exports.hasOwnProperty.call(source, key)) {\n            objectTarget[key] = clone(source[key]);\n        }\n    }\n    return objectTarget;\n}\nexports.clone = clone;\n"]},"metadata":{},"sourceType":"script"}
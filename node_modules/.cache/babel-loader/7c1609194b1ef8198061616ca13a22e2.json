{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.apply = exports.InvalidOperationError = exports.test = exports.copy = exports.move = exports.replace = exports.remove = exports.add = exports.TestError = exports.MissingError = void 0;\n\nvar pointer_1 = require(\"./pointer\");\n\nvar util_1 = require(\"./util\");\n\nvar diff_1 = require(\"./diff\");\n\nvar MissingError =\n/** @class */\nfunction (_super) {\n  __extends(MissingError, _super);\n\n  function MissingError(path) {\n    var _this = _super.call(this, \"Value required at path: \" + path) || this;\n\n    _this.path = path;\n    _this.name = 'MissingError';\n    return _this;\n  }\n\n  return MissingError;\n}(Error);\n\nexports.MissingError = MissingError;\n\nvar TestError =\n/** @class */\nfunction (_super) {\n  __extends(TestError, _super);\n\n  function TestError(actual, expected) {\n    var _this = _super.call(this, \"Test failed: \" + actual + \" != \" + expected) || this;\n\n    _this.actual = actual;\n    _this.expected = expected;\n    _this.name = 'TestError';\n    return _this;\n  }\n\n  return TestError;\n}(Error);\n\nexports.TestError = TestError;\n\nfunction _add(object, key, value) {\n  if (Array.isArray(object)) {\n    // `key` must be an index\n    if (key == '-') {\n      object.push(value);\n    } else {\n      var index = parseInt(key, 10);\n      object.splice(index, 0, value);\n    }\n  } else {\n    object[key] = value;\n  }\n}\n\nfunction _remove(object, key) {\n  if (Array.isArray(object)) {\n    // '-' syntax doesn't make sense when removing\n    var index = parseInt(key, 10);\n    object.splice(index, 1);\n  } else {\n    // not sure what the proper behavior is when path = ''\n    delete object[key];\n  }\n}\n/**\n>  o  If the target location specifies an array index, a new value is\n>     inserted into the array at the specified index.\n>  o  If the target location specifies an object member that does not\n>     already exist, a new member is added to the object.\n>  o  If the target location specifies an object member that does exist,\n>     that member's value is replaced.\n*/\n\n\nfunction add(object, operation) {\n  var endpoint = pointer_1.Pointer.fromJSON(operation.path).evaluate(object); // it's not exactly a \"MissingError\" in the same way that `remove` is -- more like a MissingParent, or something\n\n  if (endpoint.parent === undefined) {\n    return new MissingError(operation.path);\n  }\n\n  _add(endpoint.parent, endpoint.key, util_1.clone(operation.value));\n\n  return null;\n}\n\nexports.add = add;\n/**\n> The \"remove\" operation removes the value at the target location.\n> The target location MUST exist for the operation to be successful.\n*/\n\nfunction remove(object, operation) {\n  // endpoint has parent, key, and value properties\n  var endpoint = pointer_1.Pointer.fromJSON(operation.path).evaluate(object);\n\n  if (endpoint.value === undefined) {\n    return new MissingError(operation.path);\n  } // not sure what the proper behavior is when path = ''\n\n\n  _remove(endpoint.parent, endpoint.key);\n\n  return null;\n}\n\nexports.remove = remove;\n/**\n> The \"replace\" operation replaces the value at the target location\n> with a new value.  The operation object MUST contain a \"value\" member\n> whose content specifies the replacement value.\n> The target location MUST exist for the operation to be successful.\n\n> This operation is functionally identical to a \"remove\" operation for\n> a value, followed immediately by an \"add\" operation at the same\n> location with the replacement value.\n\nEven more simply, it's like the add operation with an existence check.\n*/\n\nfunction replace(object, operation) {\n  var endpoint = pointer_1.Pointer.fromJSON(operation.path).evaluate(object);\n\n  if (endpoint.parent === null) {\n    return new MissingError(operation.path);\n  } // this existence check treats arrays as a special case\n\n\n  if (Array.isArray(endpoint.parent)) {\n    if (parseInt(endpoint.key, 10) >= endpoint.parent.length) {\n      return new MissingError(operation.path);\n    }\n  } else if (endpoint.value === undefined) {\n    return new MissingError(operation.path);\n  }\n\n  endpoint.parent[endpoint.key] = operation.value;\n  return null;\n}\n\nexports.replace = replace;\n/**\n> The \"move\" operation removes the value at a specified location and\n> adds it to the target location.\n> The operation object MUST contain a \"from\" member, which is a string\n> containing a JSON Pointer value that references the location in the\n> target document to move the value from.\n> This operation is functionally identical to a \"remove\" operation on\n> the \"from\" location, followed immediately by an \"add\" operation at\n> the target location with the value that was just removed.\n\n> The \"from\" location MUST NOT be a proper prefix of the \"path\"\n> location; i.e., a location cannot be moved into one of its children.\n\nTODO: throw if the check described in the previous paragraph fails.\n*/\n\nfunction move(object, operation) {\n  var from_endpoint = pointer_1.Pointer.fromJSON(operation.from).evaluate(object);\n\n  if (from_endpoint.value === undefined) {\n    return new MissingError(operation.from);\n  }\n\n  var endpoint = pointer_1.Pointer.fromJSON(operation.path).evaluate(object);\n\n  if (endpoint.parent === undefined) {\n    return new MissingError(operation.path);\n  }\n\n  _remove(from_endpoint.parent, from_endpoint.key);\n\n  _add(endpoint.parent, endpoint.key, from_endpoint.value);\n\n  return null;\n}\n\nexports.move = move;\n/**\n> The \"copy\" operation copies the value at a specified location to the\n> target location.\n> The operation object MUST contain a \"from\" member, which is a string\n> containing a JSON Pointer value that references the location in the\n> target document to copy the value from.\n> The \"from\" location MUST exist for the operation to be successful.\n\n> This operation is functionally identical to an \"add\" operation at the\n> target location using the value specified in the \"from\" member.\n\nAlternatively, it's like 'move' without the 'remove'.\n*/\n\nfunction copy(object, operation) {\n  var from_endpoint = pointer_1.Pointer.fromJSON(operation.from).evaluate(object);\n\n  if (from_endpoint.value === undefined) {\n    return new MissingError(operation.from);\n  }\n\n  var endpoint = pointer_1.Pointer.fromJSON(operation.path).evaluate(object);\n\n  if (endpoint.parent === undefined) {\n    return new MissingError(operation.path);\n  }\n\n  _add(endpoint.parent, endpoint.key, util_1.clone(from_endpoint.value));\n\n  return null;\n}\n\nexports.copy = copy;\n/**\n> The \"test\" operation tests that a value at the target location is\n> equal to a specified value.\n> The operation object MUST contain a \"value\" member that conveys the\n> value to be compared to the target location's value.\n> The target location MUST be equal to the \"value\" value for the\n> operation to be considered successful.\n*/\n\nfunction test(object, operation) {\n  var endpoint = pointer_1.Pointer.fromJSON(operation.path).evaluate(object); // TODO: this diffAny(...).length usage could/should be lazy\n\n  if (diff_1.diffAny(endpoint.value, operation.value, new pointer_1.Pointer()).length) {\n    return new TestError(endpoint.value, operation.value);\n  }\n\n  return null;\n}\n\nexports.test = test;\n\nvar InvalidOperationError =\n/** @class */\nfunction (_super) {\n  __extends(InvalidOperationError, _super);\n\n  function InvalidOperationError(operation) {\n    var _this = _super.call(this, \"Invalid operation: \" + operation.op) || this;\n\n    _this.operation = operation;\n    _this.name = 'InvalidOperationError';\n    return _this;\n  }\n\n  return InvalidOperationError;\n}(Error);\n\nexports.InvalidOperationError = InvalidOperationError;\n/**\nSwitch on `operation.op`, applying the corresponding patch function for each\ncase to `object`.\n*/\n\nfunction apply(object, operation) {\n  // not sure why TypeScript can't infer typesafety of:\n  //   {add, remove, replace, move, copy, test}[operation.op](object, operation)\n  // (seems like a bug)\n  switch (operation.op) {\n    case 'add':\n      return add(object, operation);\n\n    case 'remove':\n      return remove(object, operation);\n\n    case 'replace':\n      return replace(object, operation);\n\n    case 'move':\n      return move(object, operation);\n\n    case 'copy':\n      return copy(object, operation);\n\n    case 'test':\n      return test(object, operation);\n  }\n\n  return new InvalidOperationError(operation);\n}\n\nexports.apply = apply;","map":{"version":3,"sources":["/Users/goldenowl/Desktop/example-boardgame/node_modules/rfc6902/patch.js"],"names":["__extends","extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","prototype","hasOwnProperty","call","TypeError","String","__","constructor","create","defineProperty","exports","value","apply","InvalidOperationError","test","copy","move","replace","remove","add","TestError","MissingError","pointer_1","require","util_1","diff_1","_super","path","_this","name","Error","actual","expected","_add","object","key","isArray","push","index","parseInt","splice","_remove","operation","endpoint","Pointer","fromJSON","evaluate","parent","undefined","clone","length","from_endpoint","from","diffAny","op"],"mappings":"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","sourcesContent":["\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.apply = exports.InvalidOperationError = exports.test = exports.copy = exports.move = exports.replace = exports.remove = exports.add = exports.TestError = exports.MissingError = void 0;\nvar pointer_1 = require(\"./pointer\");\nvar util_1 = require(\"./util\");\nvar diff_1 = require(\"./diff\");\nvar MissingError = /** @class */ (function (_super) {\n    __extends(MissingError, _super);\n    function MissingError(path) {\n        var _this = _super.call(this, \"Value required at path: \" + path) || this;\n        _this.path = path;\n        _this.name = 'MissingError';\n        return _this;\n    }\n    return MissingError;\n}(Error));\nexports.MissingError = MissingError;\nvar TestError = /** @class */ (function (_super) {\n    __extends(TestError, _super);\n    function TestError(actual, expected) {\n        var _this = _super.call(this, \"Test failed: \" + actual + \" != \" + expected) || this;\n        _this.actual = actual;\n        _this.expected = expected;\n        _this.name = 'TestError';\n        return _this;\n    }\n    return TestError;\n}(Error));\nexports.TestError = TestError;\nfunction _add(object, key, value) {\n    if (Array.isArray(object)) {\n        // `key` must be an index\n        if (key == '-') {\n            object.push(value);\n        }\n        else {\n            var index = parseInt(key, 10);\n            object.splice(index, 0, value);\n        }\n    }\n    else {\n        object[key] = value;\n    }\n}\nfunction _remove(object, key) {\n    if (Array.isArray(object)) {\n        // '-' syntax doesn't make sense when removing\n        var index = parseInt(key, 10);\n        object.splice(index, 1);\n    }\n    else {\n        // not sure what the proper behavior is when path = ''\n        delete object[key];\n    }\n}\n/**\n>  o  If the target location specifies an array index, a new value is\n>     inserted into the array at the specified index.\n>  o  If the target location specifies an object member that does not\n>     already exist, a new member is added to the object.\n>  o  If the target location specifies an object member that does exist,\n>     that member's value is replaced.\n*/\nfunction add(object, operation) {\n    var endpoint = pointer_1.Pointer.fromJSON(operation.path).evaluate(object);\n    // it's not exactly a \"MissingError\" in the same way that `remove` is -- more like a MissingParent, or something\n    if (endpoint.parent === undefined) {\n        return new MissingError(operation.path);\n    }\n    _add(endpoint.parent, endpoint.key, util_1.clone(operation.value));\n    return null;\n}\nexports.add = add;\n/**\n> The \"remove\" operation removes the value at the target location.\n> The target location MUST exist for the operation to be successful.\n*/\nfunction remove(object, operation) {\n    // endpoint has parent, key, and value properties\n    var endpoint = pointer_1.Pointer.fromJSON(operation.path).evaluate(object);\n    if (endpoint.value === undefined) {\n        return new MissingError(operation.path);\n    }\n    // not sure what the proper behavior is when path = ''\n    _remove(endpoint.parent, endpoint.key);\n    return null;\n}\nexports.remove = remove;\n/**\n> The \"replace\" operation replaces the value at the target location\n> with a new value.  The operation object MUST contain a \"value\" member\n> whose content specifies the replacement value.\n> The target location MUST exist for the operation to be successful.\n\n> This operation is functionally identical to a \"remove\" operation for\n> a value, followed immediately by an \"add\" operation at the same\n> location with the replacement value.\n\nEven more simply, it's like the add operation with an existence check.\n*/\nfunction replace(object, operation) {\n    var endpoint = pointer_1.Pointer.fromJSON(operation.path).evaluate(object);\n    if (endpoint.parent === null) {\n        return new MissingError(operation.path);\n    }\n    // this existence check treats arrays as a special case\n    if (Array.isArray(endpoint.parent)) {\n        if (parseInt(endpoint.key, 10) >= endpoint.parent.length) {\n            return new MissingError(operation.path);\n        }\n    }\n    else if (endpoint.value === undefined) {\n        return new MissingError(operation.path);\n    }\n    endpoint.parent[endpoint.key] = operation.value;\n    return null;\n}\nexports.replace = replace;\n/**\n> The \"move\" operation removes the value at a specified location and\n> adds it to the target location.\n> The operation object MUST contain a \"from\" member, which is a string\n> containing a JSON Pointer value that references the location in the\n> target document to move the value from.\n> This operation is functionally identical to a \"remove\" operation on\n> the \"from\" location, followed immediately by an \"add\" operation at\n> the target location with the value that was just removed.\n\n> The \"from\" location MUST NOT be a proper prefix of the \"path\"\n> location; i.e., a location cannot be moved into one of its children.\n\nTODO: throw if the check described in the previous paragraph fails.\n*/\nfunction move(object, operation) {\n    var from_endpoint = pointer_1.Pointer.fromJSON(operation.from).evaluate(object);\n    if (from_endpoint.value === undefined) {\n        return new MissingError(operation.from);\n    }\n    var endpoint = pointer_1.Pointer.fromJSON(operation.path).evaluate(object);\n    if (endpoint.parent === undefined) {\n        return new MissingError(operation.path);\n    }\n    _remove(from_endpoint.parent, from_endpoint.key);\n    _add(endpoint.parent, endpoint.key, from_endpoint.value);\n    return null;\n}\nexports.move = move;\n/**\n> The \"copy\" operation copies the value at a specified location to the\n> target location.\n> The operation object MUST contain a \"from\" member, which is a string\n> containing a JSON Pointer value that references the location in the\n> target document to copy the value from.\n> The \"from\" location MUST exist for the operation to be successful.\n\n> This operation is functionally identical to an \"add\" operation at the\n> target location using the value specified in the \"from\" member.\n\nAlternatively, it's like 'move' without the 'remove'.\n*/\nfunction copy(object, operation) {\n    var from_endpoint = pointer_1.Pointer.fromJSON(operation.from).evaluate(object);\n    if (from_endpoint.value === undefined) {\n        return new MissingError(operation.from);\n    }\n    var endpoint = pointer_1.Pointer.fromJSON(operation.path).evaluate(object);\n    if (endpoint.parent === undefined) {\n        return new MissingError(operation.path);\n    }\n    _add(endpoint.parent, endpoint.key, util_1.clone(from_endpoint.value));\n    return null;\n}\nexports.copy = copy;\n/**\n> The \"test\" operation tests that a value at the target location is\n> equal to a specified value.\n> The operation object MUST contain a \"value\" member that conveys the\n> value to be compared to the target location's value.\n> The target location MUST be equal to the \"value\" value for the\n> operation to be considered successful.\n*/\nfunction test(object, operation) {\n    var endpoint = pointer_1.Pointer.fromJSON(operation.path).evaluate(object);\n    // TODO: this diffAny(...).length usage could/should be lazy\n    if (diff_1.diffAny(endpoint.value, operation.value, new pointer_1.Pointer()).length) {\n        return new TestError(endpoint.value, operation.value);\n    }\n    return null;\n}\nexports.test = test;\nvar InvalidOperationError = /** @class */ (function (_super) {\n    __extends(InvalidOperationError, _super);\n    function InvalidOperationError(operation) {\n        var _this = _super.call(this, \"Invalid operation: \" + operation.op) || this;\n        _this.operation = operation;\n        _this.name = 'InvalidOperationError';\n        return _this;\n    }\n    return InvalidOperationError;\n}(Error));\nexports.InvalidOperationError = InvalidOperationError;\n/**\nSwitch on `operation.op`, applying the corresponding patch function for each\ncase to `object`.\n*/\nfunction apply(object, operation) {\n    // not sure why TypeScript can't infer typesafety of:\n    //   {add, remove, replace, move, copy, test}[operation.op](object, operation)\n    // (seems like a bug)\n    switch (operation.op) {\n        case 'add': return add(object, operation);\n        case 'remove': return remove(object, operation);\n        case 'replace': return replace(object, operation);\n        case 'move': return move(object, operation);\n        case 'copy': return copy(object, operation);\n        case 'test': return test(object, operation);\n    }\n    return new InvalidOperationError(operation);\n}\nexports.apply = apply;\n"]},"metadata":{},"sourceType":"script"}
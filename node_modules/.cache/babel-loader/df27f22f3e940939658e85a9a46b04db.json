{"ast":null,"code":"import { x as makeMove, g as gameEvent, y as alea } from './turn-order-62966a9c.js';\nimport { C as CreateGameReducer } from './reducer-763b001e.js';\n/*\r\n * Copyright 2018 The boardgame.io Authors\r\n *\r\n * Use of this source code is governed by a MIT-style\r\n * license that can be found in the LICENSE file or at\r\n * https://opensource.org/licenses/MIT.\r\n */\n\n/**\r\n * Base class that bots can extend.\r\n */\n\nclass Bot {\n  constructor({\n    enumerate,\n    seed\n  }) {\n    this.enumerateFn = enumerate;\n    this.seed = seed;\n    this.iterationCounter = 0;\n    this._opts = {};\n  }\n\n  addOpt({\n    key,\n    range,\n    initial\n  }) {\n    this._opts[key] = {\n      range,\n      value: initial\n    };\n  }\n\n  getOpt(key) {\n    return this._opts[key].value;\n  }\n\n  setOpt(key, value) {\n    if (key in this._opts) {\n      this._opts[key].value = value;\n    }\n  }\n\n  opts() {\n    return this._opts;\n  }\n\n  enumerate(G, ctx, playerID) {\n    const actions = this.enumerateFn(G, ctx, playerID);\n    return actions.map(a => {\n      if ('payload' in a) {\n        return a;\n      }\n\n      if ('move' in a) {\n        return makeMove(a.move, a.args, playerID);\n      }\n\n      if ('event' in a) {\n        return gameEvent(a.event, a.args, playerID);\n      }\n    });\n  }\n\n  random(arg) {\n    let number;\n\n    if (this.seed !== undefined) {\n      const seed = this.prngstate ? '' : this.seed;\n      const rand = alea(seed, this.prngstate);\n      number = rand();\n      this.prngstate = rand.state();\n    } else {\n      number = Math.random();\n    }\n\n    if (arg) {\n      if (Array.isArray(arg)) {\n        const id = Math.floor(number * arg.length);\n        return arg[id];\n      } else {\n        return Math.floor(number * arg);\n      }\n    }\n\n    return number;\n  }\n\n}\n/*\r\n * Copyright 2018 The boardgame.io Authors\r\n *\r\n * Use of this source code is governed by a MIT-style\r\n * license that can be found in the LICENSE file or at\r\n * https://opensource.org/licenses/MIT.\r\n */\n\n/**\r\n * The number of iterations to run before yielding to\r\n * the JS event loop (in async mode).\r\n */\n\n\nconst CHUNK_SIZE = 25;\n/**\r\n * Bot that uses Monte-Carlo Tree Search to find promising moves.\r\n */\n\nclass MCTSBot extends Bot {\n  constructor({\n    enumerate,\n    seed,\n    objectives,\n    game,\n    iterations,\n    playoutDepth,\n    iterationCallback\n  }) {\n    super({\n      enumerate,\n      seed\n    });\n\n    if (objectives === undefined) {\n      objectives = () => ({});\n    }\n\n    this.objectives = objectives;\n\n    this.iterationCallback = iterationCallback || (() => {});\n\n    this.reducer = CreateGameReducer({\n      game\n    });\n    this.iterations = iterations;\n    this.playoutDepth = playoutDepth;\n    this.addOpt({\n      key: 'async',\n      initial: false\n    });\n    this.addOpt({\n      key: 'iterations',\n      initial: typeof iterations === 'number' ? iterations : 1000,\n      range: {\n        min: 1,\n        max: 2000\n      }\n    });\n    this.addOpt({\n      key: 'playoutDepth',\n      initial: typeof playoutDepth === 'number' ? playoutDepth : 50,\n      range: {\n        min: 1,\n        max: 100\n      }\n    });\n  }\n\n  createNode({\n    state,\n    parentAction,\n    parent,\n    playerID\n  }) {\n    const {\n      G,\n      ctx\n    } = state;\n    let actions = [];\n    let objectives = [];\n\n    if (playerID !== undefined) {\n      actions = this.enumerate(G, ctx, playerID);\n      objectives = this.objectives(G, ctx, playerID);\n    } else if (ctx.activePlayers) {\n      for (const playerID in ctx.activePlayers) {\n        actions = actions.concat(this.enumerate(G, ctx, playerID));\n        objectives = objectives.concat(this.objectives(G, ctx, playerID));\n      }\n    } else {\n      actions = actions.concat(this.enumerate(G, ctx, ctx.currentPlayer));\n      objectives = objectives.concat(this.objectives(G, ctx, ctx.currentPlayer));\n    }\n\n    return {\n      state,\n      parent,\n      parentAction,\n      actions,\n      objectives,\n      children: [],\n      visits: 0,\n      value: 0\n    };\n  }\n\n  select(node) {\n    // This node has unvisited children.\n    if (node.actions.length > 0) {\n      return node;\n    } // This is a terminal node.\n\n\n    if (node.children.length == 0) {\n      return node;\n    }\n\n    let selectedChild = null;\n    let best = 0;\n\n    for (const child of node.children) {\n      const childVisits = child.visits + Number.EPSILON;\n      const uct = child.value / childVisits + Math.sqrt(2 * Math.log(node.visits) / childVisits);\n\n      if (selectedChild == null || uct > best) {\n        best = uct;\n        selectedChild = child;\n      }\n    }\n\n    return this.select(selectedChild);\n  }\n\n  expand(node) {\n    const actions = node.actions;\n\n    if (actions.length == 0 || node.state.ctx.gameover !== undefined) {\n      return node;\n    }\n\n    const id = this.random(actions.length);\n    const action = actions[id];\n    node.actions.splice(id, 1);\n    const childState = this.reducer(node.state, action);\n    const childNode = this.createNode({\n      state: childState,\n      parentAction: action,\n      parent: node\n    });\n    node.children.push(childNode);\n    return childNode;\n  }\n\n  playout({\n    state\n  }) {\n    let playoutDepth = this.getOpt('playoutDepth');\n\n    if (typeof this.playoutDepth === 'function') {\n      playoutDepth = this.playoutDepth(state.G, state.ctx);\n    }\n\n    for (let i = 0; i < playoutDepth && state.ctx.gameover === undefined; i++) {\n      const {\n        G,\n        ctx\n      } = state;\n      let playerID = ctx.currentPlayer;\n\n      if (ctx.activePlayers) {\n        playerID = Object.keys(ctx.activePlayers)[0];\n      }\n\n      const moves = this.enumerate(G, ctx, playerID); // Check if any objectives are met.\n\n      const objectives = this.objectives(G, ctx, playerID);\n      const score = Object.keys(objectives).reduce((score, key) => {\n        const objective = objectives[key];\n\n        if (objective.checker(G, ctx)) {\n          return score + objective.weight;\n        }\n\n        return score;\n      }, 0); // If so, stop and return the score.\n\n      if (score > 0) {\n        return {\n          score\n        };\n      }\n\n      if (!moves || moves.length == 0) {\n        return undefined;\n      }\n\n      const id = this.random(moves.length);\n      const childState = this.reducer(state, moves[id]);\n      state = childState;\n    }\n\n    return state.ctx.gameover;\n  }\n\n  backpropagate(node, result = {}) {\n    node.visits++;\n\n    if (result.score !== undefined) {\n      node.value += result.score;\n    }\n\n    if (result.draw === true) {\n      node.value += 0.5;\n    }\n\n    if (node.parentAction && result.winner === node.parentAction.payload.playerID) {\n      node.value++;\n    }\n\n    if (node.parent) {\n      this.backpropagate(node.parent, result);\n    }\n  }\n\n  play(state, playerID) {\n    const root = this.createNode({\n      state,\n      playerID\n    });\n    let numIterations = this.getOpt('iterations');\n\n    if (typeof this.iterations === 'function') {\n      numIterations = this.iterations(state.G, state.ctx);\n    }\n\n    const getResult = () => {\n      let selectedChild = null;\n\n      for (const child of root.children) {\n        if (selectedChild == null || child.visits > selectedChild.visits) {\n          selectedChild = child;\n        }\n      }\n\n      const action = selectedChild && selectedChild.parentAction;\n      const metadata = root;\n      return {\n        action,\n        metadata\n      };\n    };\n\n    return new Promise(resolve => {\n      const iteration = () => {\n        for (let i = 0; i < CHUNK_SIZE && this.iterationCounter < numIterations; i++) {\n          const leaf = this.select(root);\n          const child = this.expand(leaf);\n          const result = this.playout(child);\n          this.backpropagate(child, result);\n          this.iterationCounter++;\n        }\n\n        this.iterationCallback({\n          iterationCounter: this.iterationCounter,\n          numIterations,\n          metadata: root\n        });\n      };\n\n      this.iterationCounter = 0;\n\n      if (this.getOpt('async')) {\n        const asyncIteration = () => {\n          if (this.iterationCounter < numIterations) {\n            iteration();\n            setTimeout(asyncIteration, 0);\n          } else {\n            resolve(getResult());\n          }\n        };\n\n        asyncIteration();\n      } else {\n        while (this.iterationCounter < numIterations) {\n          iteration();\n        }\n\n        resolve(getResult());\n      }\n    });\n  }\n\n}\n/*\r\n * Copyright 2018 The boardgame.io Authors\r\n *\r\n * Use of this source code is governed by a MIT-style\r\n * license that can be found in the LICENSE file or at\r\n * https://opensource.org/licenses/MIT.\r\n */\n\n/**\r\n * Bot that picks a move at random.\r\n */\n\n\nclass RandomBot extends Bot {\n  play({\n    G,\n    ctx\n  }, playerID) {\n    const moves = this.enumerate(G, ctx, playerID);\n    return Promise.resolve({\n      action: this.random(moves)\n    });\n  }\n\n}\n/*\r\n * Copyright 2018 The boardgame.io Authors\r\n *\r\n * Use of this source code is governed by a MIT-style\r\n * license that can be found in the LICENSE file or at\r\n * https://opensource.org/licenses/MIT.\r\n */\n\n/**\r\n * Make a single move on the client with a bot.\r\n *\r\n * @param {...object} client - The game client.\r\n * @param {...object} bot - The bot.\r\n */\n\n\nasync function Step(client, bot) {\n  const state = client.store.getState();\n  let playerID = state.ctx.currentPlayer;\n\n  if (state.ctx.activePlayers) {\n    playerID = Object.keys(state.ctx.activePlayers)[0];\n  }\n\n  const {\n    action,\n    metadata\n  } = await bot.play(state, playerID);\n\n  if (action) {\n    const a = { ...action,\n      payload: { ...action.payload,\n        metadata\n      }\n    };\n    client.store.dispatch(a);\n    return a;\n  }\n}\n/**\r\n * Simulates the game till the end or a max depth.\r\n *\r\n * @param {...object} game - The game object.\r\n * @param {...object} bots - An array of bots.\r\n * @param {...object} state - The game state to start from.\r\n */\n\n\nasync function Simulate({\n  game,\n  bots,\n  state,\n  depth\n}) {\n  if (depth === undefined) depth = 10000;\n  const reducer = CreateGameReducer({\n    game\n  });\n  let metadata = null;\n  let iter = 0;\n\n  while (state.ctx.gameover === undefined && iter < depth) {\n    let playerID = state.ctx.currentPlayer;\n\n    if (state.ctx.activePlayers) {\n      playerID = Object.keys(state.ctx.activePlayers)[0];\n    }\n\n    const bot = bots instanceof Bot ? bots : bots[playerID];\n    const t = await bot.play(state, playerID);\n\n    if (!t.action) {\n      break;\n    }\n\n    metadata = t.metadata;\n    state = reducer(state, t.action);\n    iter++;\n  }\n\n  return {\n    state,\n    metadata\n  };\n}\n\nexport { Bot as B, MCTSBot as M, RandomBot as R, Step as S, Simulate as a };","map":{"version":3,"sources":["/Users/goldenowl/Desktop/example-boardgame/node_modules/boardgame.io/dist/esm/ai-92d44551.js"],"names":["x","makeMove","g","gameEvent","y","alea","C","CreateGameReducer","Bot","constructor","enumerate","seed","enumerateFn","iterationCounter","_opts","addOpt","key","range","initial","value","getOpt","setOpt","opts","G","ctx","playerID","actions","map","a","move","args","event","random","arg","number","undefined","prngstate","rand","state","Math","Array","isArray","id","floor","length","CHUNK_SIZE","MCTSBot","objectives","game","iterations","playoutDepth","iterationCallback","reducer","min","max","createNode","parentAction","parent","activePlayers","concat","currentPlayer","children","visits","select","node","selectedChild","best","child","childVisits","Number","EPSILON","uct","sqrt","log","expand","gameover","action","splice","childState","childNode","push","playout","i","Object","keys","moves","score","reduce","objective","checker","weight","backpropagate","result","draw","winner","payload","play","root","numIterations","getResult","metadata","Promise","resolve","iteration","leaf","asyncIteration","setTimeout","RandomBot","Step","client","bot","store","getState","dispatch","Simulate","bots","depth","iter","t","B","M","R","S"],"mappings":"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","sourcesContent":["import { x as makeMove, g as gameEvent, y as alea } from './turn-order-62966a9c.js';\nimport { C as CreateGameReducer } from './reducer-763b001e.js';\n\n/*\r\n * Copyright 2018 The boardgame.io Authors\r\n *\r\n * Use of this source code is governed by a MIT-style\r\n * license that can be found in the LICENSE file or at\r\n * https://opensource.org/licenses/MIT.\r\n */\r\n/**\r\n * Base class that bots can extend.\r\n */\r\nclass Bot {\r\n    constructor({ enumerate, seed, }) {\r\n        this.enumerateFn = enumerate;\r\n        this.seed = seed;\r\n        this.iterationCounter = 0;\r\n        this._opts = {};\r\n    }\r\n    addOpt({ key, range, initial, }) {\r\n        this._opts[key] = {\r\n            range,\r\n            value: initial,\r\n        };\r\n    }\r\n    getOpt(key) {\r\n        return this._opts[key].value;\r\n    }\r\n    setOpt(key, value) {\r\n        if (key in this._opts) {\r\n            this._opts[key].value = value;\r\n        }\r\n    }\r\n    opts() {\r\n        return this._opts;\r\n    }\r\n    enumerate(G, ctx, playerID) {\r\n        const actions = this.enumerateFn(G, ctx, playerID);\r\n        return actions.map((a) => {\r\n            if ('payload' in a) {\r\n                return a;\r\n            }\r\n            if ('move' in a) {\r\n                return makeMove(a.move, a.args, playerID);\r\n            }\r\n            if ('event' in a) {\r\n                return gameEvent(a.event, a.args, playerID);\r\n            }\r\n        });\r\n    }\r\n    random(arg) {\r\n        let number;\r\n        if (this.seed !== undefined) {\r\n            const seed = this.prngstate ? '' : this.seed;\r\n            const rand = alea(seed, this.prngstate);\r\n            number = rand();\r\n            this.prngstate = rand.state();\r\n        }\r\n        else {\r\n            number = Math.random();\r\n        }\r\n        if (arg) {\r\n            if (Array.isArray(arg)) {\r\n                const id = Math.floor(number * arg.length);\r\n                return arg[id];\r\n            }\r\n            else {\r\n                return Math.floor(number * arg);\r\n            }\r\n        }\r\n        return number;\r\n    }\r\n}\n\n/*\r\n * Copyright 2018 The boardgame.io Authors\r\n *\r\n * Use of this source code is governed by a MIT-style\r\n * license that can be found in the LICENSE file or at\r\n * https://opensource.org/licenses/MIT.\r\n */\r\n/**\r\n * The number of iterations to run before yielding to\r\n * the JS event loop (in async mode).\r\n */\r\nconst CHUNK_SIZE = 25;\r\n/**\r\n * Bot that uses Monte-Carlo Tree Search to find promising moves.\r\n */\r\nclass MCTSBot extends Bot {\r\n    constructor({ enumerate, seed, objectives, game, iterations, playoutDepth, iterationCallback, }) {\r\n        super({ enumerate, seed });\r\n        if (objectives === undefined) {\r\n            objectives = () => ({});\r\n        }\r\n        this.objectives = objectives;\r\n        this.iterationCallback = iterationCallback || (() => { });\r\n        this.reducer = CreateGameReducer({ game });\r\n        this.iterations = iterations;\r\n        this.playoutDepth = playoutDepth;\r\n        this.addOpt({\r\n            key: 'async',\r\n            initial: false,\r\n        });\r\n        this.addOpt({\r\n            key: 'iterations',\r\n            initial: typeof iterations === 'number' ? iterations : 1000,\r\n            range: { min: 1, max: 2000 },\r\n        });\r\n        this.addOpt({\r\n            key: 'playoutDepth',\r\n            initial: typeof playoutDepth === 'number' ? playoutDepth : 50,\r\n            range: { min: 1, max: 100 },\r\n        });\r\n    }\r\n    createNode({ state, parentAction, parent, playerID, }) {\r\n        const { G, ctx } = state;\r\n        let actions = [];\r\n        let objectives = [];\r\n        if (playerID !== undefined) {\r\n            actions = this.enumerate(G, ctx, playerID);\r\n            objectives = this.objectives(G, ctx, playerID);\r\n        }\r\n        else if (ctx.activePlayers) {\r\n            for (const playerID in ctx.activePlayers) {\r\n                actions = actions.concat(this.enumerate(G, ctx, playerID));\r\n                objectives = objectives.concat(this.objectives(G, ctx, playerID));\r\n            }\r\n        }\r\n        else {\r\n            actions = actions.concat(this.enumerate(G, ctx, ctx.currentPlayer));\r\n            objectives = objectives.concat(this.objectives(G, ctx, ctx.currentPlayer));\r\n        }\r\n        return {\r\n            state,\r\n            parent,\r\n            parentAction,\r\n            actions,\r\n            objectives,\r\n            children: [],\r\n            visits: 0,\r\n            value: 0,\r\n        };\r\n    }\r\n    select(node) {\r\n        // This node has unvisited children.\r\n        if (node.actions.length > 0) {\r\n            return node;\r\n        }\r\n        // This is a terminal node.\r\n        if (node.children.length == 0) {\r\n            return node;\r\n        }\r\n        let selectedChild = null;\r\n        let best = 0;\r\n        for (const child of node.children) {\r\n            const childVisits = child.visits + Number.EPSILON;\r\n            const uct = child.value / childVisits +\r\n                Math.sqrt((2 * Math.log(node.visits)) / childVisits);\r\n            if (selectedChild == null || uct > best) {\r\n                best = uct;\r\n                selectedChild = child;\r\n            }\r\n        }\r\n        return this.select(selectedChild);\r\n    }\r\n    expand(node) {\r\n        const actions = node.actions;\r\n        if (actions.length == 0 || node.state.ctx.gameover !== undefined) {\r\n            return node;\r\n        }\r\n        const id = this.random(actions.length);\r\n        const action = actions[id];\r\n        node.actions.splice(id, 1);\r\n        const childState = this.reducer(node.state, action);\r\n        const childNode = this.createNode({\r\n            state: childState,\r\n            parentAction: action,\r\n            parent: node,\r\n        });\r\n        node.children.push(childNode);\r\n        return childNode;\r\n    }\r\n    playout({ state }) {\r\n        let playoutDepth = this.getOpt('playoutDepth');\r\n        if (typeof this.playoutDepth === 'function') {\r\n            playoutDepth = this.playoutDepth(state.G, state.ctx);\r\n        }\r\n        for (let i = 0; i < playoutDepth && state.ctx.gameover === undefined; i++) {\r\n            const { G, ctx } = state;\r\n            let playerID = ctx.currentPlayer;\r\n            if (ctx.activePlayers) {\r\n                playerID = Object.keys(ctx.activePlayers)[0];\r\n            }\r\n            const moves = this.enumerate(G, ctx, playerID);\r\n            // Check if any objectives are met.\r\n            const objectives = this.objectives(G, ctx, playerID);\r\n            const score = Object.keys(objectives).reduce((score, key) => {\r\n                const objective = objectives[key];\r\n                if (objective.checker(G, ctx)) {\r\n                    return score + objective.weight;\r\n                }\r\n                return score;\r\n            }, 0);\r\n            // If so, stop and return the score.\r\n            if (score > 0) {\r\n                return { score };\r\n            }\r\n            if (!moves || moves.length == 0) {\r\n                return undefined;\r\n            }\r\n            const id = this.random(moves.length);\r\n            const childState = this.reducer(state, moves[id]);\r\n            state = childState;\r\n        }\r\n        return state.ctx.gameover;\r\n    }\r\n    backpropagate(node, result = {}) {\r\n        node.visits++;\r\n        if (result.score !== undefined) {\r\n            node.value += result.score;\r\n        }\r\n        if (result.draw === true) {\r\n            node.value += 0.5;\r\n        }\r\n        if (node.parentAction &&\r\n            result.winner === node.parentAction.payload.playerID) {\r\n            node.value++;\r\n        }\r\n        if (node.parent) {\r\n            this.backpropagate(node.parent, result);\r\n        }\r\n    }\r\n    play(state, playerID) {\r\n        const root = this.createNode({ state, playerID });\r\n        let numIterations = this.getOpt('iterations');\r\n        if (typeof this.iterations === 'function') {\r\n            numIterations = this.iterations(state.G, state.ctx);\r\n        }\r\n        const getResult = () => {\r\n            let selectedChild = null;\r\n            for (const child of root.children) {\r\n                if (selectedChild == null || child.visits > selectedChild.visits) {\r\n                    selectedChild = child;\r\n                }\r\n            }\r\n            const action = selectedChild && selectedChild.parentAction;\r\n            const metadata = root;\r\n            return { action, metadata };\r\n        };\r\n        return new Promise((resolve) => {\r\n            const iteration = () => {\r\n                for (let i = 0; i < CHUNK_SIZE && this.iterationCounter < numIterations; i++) {\r\n                    const leaf = this.select(root);\r\n                    const child = this.expand(leaf);\r\n                    const result = this.playout(child);\r\n                    this.backpropagate(child, result);\r\n                    this.iterationCounter++;\r\n                }\r\n                this.iterationCallback({\r\n                    iterationCounter: this.iterationCounter,\r\n                    numIterations,\r\n                    metadata: root,\r\n                });\r\n            };\r\n            this.iterationCounter = 0;\r\n            if (this.getOpt('async')) {\r\n                const asyncIteration = () => {\r\n                    if (this.iterationCounter < numIterations) {\r\n                        iteration();\r\n                        setTimeout(asyncIteration, 0);\r\n                    }\r\n                    else {\r\n                        resolve(getResult());\r\n                    }\r\n                };\r\n                asyncIteration();\r\n            }\r\n            else {\r\n                while (this.iterationCounter < numIterations) {\r\n                    iteration();\r\n                }\r\n                resolve(getResult());\r\n            }\r\n        });\r\n    }\r\n}\n\n/*\r\n * Copyright 2018 The boardgame.io Authors\r\n *\r\n * Use of this source code is governed by a MIT-style\r\n * license that can be found in the LICENSE file or at\r\n * https://opensource.org/licenses/MIT.\r\n */\r\n/**\r\n * Bot that picks a move at random.\r\n */\r\nclass RandomBot extends Bot {\r\n    play({ G, ctx }, playerID) {\r\n        const moves = this.enumerate(G, ctx, playerID);\r\n        return Promise.resolve({ action: this.random(moves) });\r\n    }\r\n}\n\n/*\r\n * Copyright 2018 The boardgame.io Authors\r\n *\r\n * Use of this source code is governed by a MIT-style\r\n * license that can be found in the LICENSE file or at\r\n * https://opensource.org/licenses/MIT.\r\n */\r\n/**\r\n * Make a single move on the client with a bot.\r\n *\r\n * @param {...object} client - The game client.\r\n * @param {...object} bot - The bot.\r\n */\r\nasync function Step(client, bot) {\r\n    const state = client.store.getState();\r\n    let playerID = state.ctx.currentPlayer;\r\n    if (state.ctx.activePlayers) {\r\n        playerID = Object.keys(state.ctx.activePlayers)[0];\r\n    }\r\n    const { action, metadata } = await bot.play(state, playerID);\r\n    if (action) {\r\n        const a = {\r\n            ...action,\r\n            payload: {\r\n                ...action.payload,\r\n                metadata,\r\n            },\r\n        };\r\n        client.store.dispatch(a);\r\n        return a;\r\n    }\r\n}\r\n/**\r\n * Simulates the game till the end or a max depth.\r\n *\r\n * @param {...object} game - The game object.\r\n * @param {...object} bots - An array of bots.\r\n * @param {...object} state - The game state to start from.\r\n */\r\nasync function Simulate({ game, bots, state, depth, }) {\r\n    if (depth === undefined)\r\n        depth = 10000;\r\n    const reducer = CreateGameReducer({ game });\r\n    let metadata = null;\r\n    let iter = 0;\r\n    while (state.ctx.gameover === undefined && iter < depth) {\r\n        let playerID = state.ctx.currentPlayer;\r\n        if (state.ctx.activePlayers) {\r\n            playerID = Object.keys(state.ctx.activePlayers)[0];\r\n        }\r\n        const bot = bots instanceof Bot ? bots : bots[playerID];\r\n        const t = await bot.play(state, playerID);\r\n        if (!t.action) {\r\n            break;\r\n        }\r\n        metadata = t.metadata;\r\n        state = reducer(state, t.action);\r\n        iter++;\r\n    }\r\n    return { state, metadata };\r\n}\n\nexport { Bot as B, MCTSBot as M, RandomBot as R, Step as S, Simulate as a };\n"]},"metadata":{},"sourceType":"module"}